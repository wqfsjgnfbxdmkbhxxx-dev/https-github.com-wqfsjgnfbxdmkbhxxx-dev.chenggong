<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>æŠ˜é£æ–‡å­¦åŸ - ä½œå®¶çµæ„Ÿåˆ›ä½œä¸­å¿ƒ v2.3 (Mist Theme)</title>
    
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link href="https://fonts.bunny.net/css?family=cinzel:400,500|la-belle-aurore:400|noto-sans-sc:300,400,500,700|noto-serif-sc:400,600|zcool-xiaowei:400" rel="stylesheet" />

    <style>
        /* --- Mist Theme Integration --- */
        :root {
            /* Mist å˜é‡ */
            --bg-color: #fdfbf7;
            --text-main: #2c3e50;
            --text-sub: #607d8b;
            --glass-bg: rgba(255, 255, 255, 0.65);
            --glass-border: rgba(255, 255, 255, 0.6);
            --shadow-soft: 0 10px 40px -10px rgba(31, 38, 135, 0.08);
            
            /* æŠ˜é£åŸæœ‰å˜é‡é€‚é… */
            --jj-green: #4a7c59; /* è°ƒæ•´ä¸ºæ›´æŸ”å’Œçš„ç»¿è‰²ä»¥åŒ¹é… Mist */
            --jj-light-green: rgba(74, 124, 89, 0.1);
            --jj-pink: #ffc0cb;
            --jj-text: var(--text-main);
            --jj-gray: var(--text-sub);
            --jj-border: rgba(0,0,0,0.08);
            --reader-bg: rgba(246, 244, 236, 0.9);

            /* å­—ä½“å˜é‡ */
            --font-sans: 'Noto Sans SC', system-ui, -apple-system, "Microsoft YaHei", sans-serif;
            --font-serif: 'Noto Serif SC', "Songti SC", serif;
            --font-art: 'ZCOOL XiaoWei', serif;
            --font-en: 'Cinzel', serif;
            --font-hand: 'La Belle Aurore', cursive;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--bg-color);
            color: var(--text-main);
            line-height: 1.6;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            padding-bottom: 100px; /* ä¸ºåº•éƒ¨å¯¼èˆªç•™ç©ºé—´ */
            touch-action: manipulation; /* ç¦æ­¢åŒå‡»ç¼©æ”¾ */
        }
        
        /* å…¨å±€å­—ä½“åº”ç”¨ */
        h1, h2, h3, h4, h5, h6, .header-logo, .reader-title {
            font-family: var(--font-sans) !important;
        }

        /* èƒŒæ™¯å±‚ */
        #app-background {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2;
            background-image: 
                radial-gradient(at 10% 10%, rgba(96, 125, 139, 0.05) 0px, transparent 50%),
                radial-gradient(at 90% 90%, rgba(200, 200, 200, 0.1) 0px, transparent 50%);
            background-size: cover; background-position: center;
        }
        #app-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
            background-color: black; opacity: 0; pointer-events: none;
        }

        /* æ·±è‰²æ¨¡å¼é€‚é… */
        [data-theme="dark"] {
            --bg-color: #121212;
            --text-main: #e0e0e0;
            --text-sub: #a0a0a0;
            --glass-bg: rgba(30, 30, 30, 0.8);
            --glass-border: rgba(255, 255, 255, 0.1);
            --shadow-soft: 0 10px 40px -10px rgba(0, 0, 0, 0.6);
            --jj-green: #6b9c7b;
            --jj-light-green: rgba(107, 156, 123, 0.2);
            --jj-pink: #a16b73;
            --jj-border: rgba(255,255,255,0.1);
            --reader-bg: rgba(35, 35, 35, 0.95);
        }
        [data-theme="dark"] .card, 
        [data-theme="dark"] .navbar,
        [data-theme="dark"] .float-panel,
        [data-theme="dark"] .catalog-content {
            background: var(--glass-bg);
        }
        [data-theme="dark"] input, 
        [data-theme="dark"] textarea, 
        [data-theme="dark"] select {
            background: rgba(0,0,0,0.3);
            color: var(--text-main);
            border-color: rgba(255,255,255,0.1);
        }
        [data-theme="dark"] .shelf-book {
            background: rgba(255,255,255,0.05);
        }
        [data-theme="dark"] .shelf-book:hover {
            background: rgba(255,255,255,0.1);
        }
        [data-theme="dark"] .tag-chip {
            background: rgba(255,255,255,0.1);
        }
        [data-theme="dark"] .book-preview-item:hover {
            background: rgba(255,255,255,0.05);
        }

        /* Switch å¼€å…³ */
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--jj-green); }
        input:checked + .slider:before { transform: translateX(26px); }

        /* é€šç”¨ç»„ä»¶ */
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        
        /* å¡ç‰‡ -> æ¯›ç»ç’ƒé¢æ¿ */
        .card { 
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(140%);
            -webkit-backdrop-filter: blur(20px) saturate(140%);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: var(--shadow-soft);
            padding: 24px;
            margin-bottom: 24px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            animation: fade-up 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 30px -10px rgba(31, 38, 135, 0.12);
        }

        /* æŒ‰é’®é€‚é… */
        .btn { 
            padding: 10px 24px; 
            border: none; 
            border-radius: 50px; 
            cursor: pointer; 
            font-family: var(--font-serif);
            font-size: 14px; 
            transition: all 0.3s ease; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            font-weight: 600;
        }
        .btn:active { opacity: 0.8; transform: scale(0.98); }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; box-shadow: none !important; background: rgba(0,0,0,0.1); color: #999; border-color: transparent; }
        
        .btn-jj { background-color: var(--jj-green); color: white; }
        .btn-jj:hover { background-color: #3a6346; }
        
        .btn-outline { border: 1px solid var(--jj-green); color: var(--jj-green); background: transparent; }
        .btn-outline:hover { background: var(--jj-green); color: white; }
        
        .btn-danger { border: 1px solid #ff4d4f; color: #ff4d4f; background: transparent; }
        .btn-danger:hover { background: #ff4d4f; color: white; }

        /* è¾“å…¥æ¡†é€‚é… */
        .input-group { margin-bottom: 20px; }
        .input-group label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--jj-green); font-family: var(--font-serif); }
        input, textarea, select { 
            width: 100%; 
            padding: 12px; 
            border: 1px solid rgba(0,0,0,0.1); 
            border-radius: 8px; 
            box-sizing: border-box; 
            background: rgba(255,255,255,0.5);
            font-family: var(--font-sans);
            transition: all 0.3s;
            font-size: 15px;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            background: rgba(255,255,255,0.9);
            border-color: var(--jj-green);
            box-shadow: 0 0 0 3px rgba(74, 124, 89, 0.1);
        }
        
        /* å¯¼èˆªæ é€‚é… */
        .navbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 500px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            display: flex; justify-content: space-around; padding: 12px 20px;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .nav-item { text-align: center; color: var(--text-sub); cursor: pointer; font-size: 12px; transition: all 0.3s; }
        .nav-item.active { color: var(--jj-green); font-weight: bold; transform: translateY(-2px); }
        .nav-icon { display: block; font-size: 22px; margin-bottom: 2px; }

        /* é¡µé¢æ˜¾ç¤ºæ§åˆ¶ */
        .page { display: none; }
        .page.active { display: block; animation: fadeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
        @keyframes fade-up { to { opacity: 1; transform: translateY(0); } }

        /* --- é¦–é¡µï¼šåˆ›ä½œä¸­å¿ƒ --- */
        .header-logo { 
            font-family: var(--font-art); 
            color: var(--text-main); 
            font-size: 36px; 
            text-align: center; 
            margin: 40px 0 5px 0; 
            animation: float 6s ease-in-out infinite;
        }
        .header-subtitle {
            font-family: var(--font-en);
            text-align: center;
            color: var(--text-sub);
            font-size: 12px;
            letter-spacing: 0.2em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        /* æœç´¢æ¡†å®¹å™¨é‡æ„ */
        .search-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            background: rgba(255,255,255,0.5);
            min-height: 50px;
            align-items: center;
            transition: all 0.3s;
            cursor: text;
        }
        .search-wrapper:focus-within {
            background: rgba(255,255,255,0.9);
            border-color: var(--jj-green);
            box-shadow: 0 0 0 3px rgba(74, 124, 89, 0.1);
        }
        .search-input-field {
            flex: 1;
            min-width: 100px;
            border: none;
            background: transparent;
            padding: 5px;
            font-size: 15px;
            outline: none;
            font-family: var(--font-sans);
        }
        .search-tag-item {
            background: var(--jj-green);
            color: white;
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 5px;
            animation: scaleIn 0.2s ease;
        }
        .search-tag-remove {
            cursor: pointer;
            opacity: 0.8;
            font-weight: bold;
        }
        .search-tag-remove:hover { opacity: 1; }
        @keyframes scaleIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* æ ‡ç­¾æ± ä¼˜åŒ– */
        .tag-cloud { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 8px; 
            margin-top: 15px; 
            max-height: 150px; /* å›ºå®šé«˜åº¦ */
            overflow-y: auto; /* æ”¯æŒæ»šåŠ¨ */
            padding: 5px;
            border-top: 1px dashed rgba(0,0,0,0.05);
            padding-top: 15px;
        }
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        .tag-cloud::-webkit-scrollbar { width: 4px; }
        .tag-cloud::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 2px; }

        .tag-chip { 
            background: rgba(74, 124, 89, 0.1); 
            color: var(--jj-green); 
            padding: 6px 14px; 
            border-radius: 20px; 
            font-size: 13px; 
            cursor: pointer; 
            border: 1px solid transparent;
            transition: all 0.2s;
            user-select: none;
        }
        .tag-chip:hover, .tag-chip.active { background: var(--jj-green); color: white; box-shadow: 0 2px 8px rgba(74, 124, 89, 0.4); }
        .tag-chip.pinned { border: 1px solid rgba(74, 124, 89, 0.3); background: rgba(74, 124, 89, 0.15); font-weight: 500; }
        .tag-chip.custom { border: 1px solid var(--jj-green); background: transparent; }
        .tag-chip.custom:hover, .tag-chip.custom.active { background: var(--jj-green); color: white; }

        .book-preview-item { 
            display: flex; 
            border-bottom: 1px solid rgba(0,0,0,0.05); 
            padding: 15px; 
            cursor: pointer; 
            transition: all 0.3s ease; 
            border-radius: 8px; 
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.03);
        }
        .book-preview-item:hover { 
            background: rgba(255, 255, 255, 0.7);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
        }
        .book-info { flex: 1; } 
        .book-info h3 { margin: 0 0 5px 0; font-size: 18px; color: var(--text-main); font-weight: bold; font-family: var(--font-serif);}
        .book-meta { font-size: 12px; color: var(--text-sub); margin-bottom: 8px; font-family: var(--font-sans); }
        .book-intro { font-size: 14px; color: #555; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.6; }

        /* --- åˆ†é¡µæ§ä»¶ --- */
        .pagination-container { display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 20px; padding-bottom: 20px; }
        .page-num { font-size: 14px; color: var(--text-sub); font-family: var(--font-en); }

        /* --- ä¹¦ç±è¯¦æƒ…é¡µ --- */
        .jj-detail-header { display: flex; gap: 20px; margin-bottom: 25px; }
        .jj-cover-lg { 
            width: 120px; height: 160px; 
            background: #f0f0f0; 
            box-shadow: 5px 5px 15px rgba(0,0,0,0.1); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; 
            padding: 10px; font-family: var(--font-serif); 
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.05);
        }
        .jj-meta-info h1 { margin: 0 0 15px 0; font-size: 24px; color: var(--text-main); font-family: var(--font-serif); }
        .jj-stat-row { font-size: 14px; color: var(--text-main); margin-bottom: 6px; }
        .jj-copy-box { 
            border: 1px dashed var(--jj-green); 
            background: rgba(74, 124, 89, 0.05);
            padding: 20px; 
            font-size: 15px; 
            line-height: 1.8; 
            color: var(--text-main); 
            margin-bottom: 20px; 
            white-space: pre-wrap; 
            border-radius: 8px;
        }
        .jj-tags { font-size: 13px; color: var(--jj-green); margin-top: 10px; }
        .jj-tag-item { color: var(--text-main); font-weight: normal; background: rgba(0,0,0,0.05); padding: 2px 6px; border-radius: 4px; margin-right: 5px; }
        
        .jj-chapter-list { border: 1px solid rgba(0,0,0,0.1); max-height: 400px; overflow-y: auto; border-radius: 8px; background: rgba(255,255,255,0.3); }
        .jj-chapter-row { padding: 12px 15px; border-bottom: 1px solid rgba(0,0,0,0.05); display: flex; justify-content: space-between; font-size: 14px; cursor: pointer; transition: background 0.2s; }
        .jj-chapter-row:hover { background-color: rgba(74, 124, 89, 0.1); }
        .jj-chapter-row:last-child { border-bottom: none; }
        .jj-vip { color: #ff4d4f; font-size: 12px; border: 1px solid #ff4d4f; padding: 0 4px; margin-left: 5px; border-radius: 2px; }

        /* --- é˜…è¯»å™¨é¡µé¢ --- */
        .reader-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 1000;
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            transition: all 0.3s;
        }
        [data-theme="dark"] .reader-header {
            background: rgba(30, 30, 30, 0.95);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .reader-content { 
            background-color: var(--reader-bg); 
            padding: 15px; 
            margin-top: 60px; /* é€‚é…å›ºå®šå¯¼èˆªæ  */
            min-height: 50vh; 
            line-height: 1.7; /* ä¼˜åŒ–ï¼šæ›´ç´§å‡‘çš„è¡Œé«˜ */
            font-size: 17px; /* ä¼˜åŒ–ï¼šå¾®è°ƒå­—å· */
            color: #2b2b2b; 
            white-space: normal; /* ä¿®æ”¹ï¼šé¿å…æºç ä¸­çš„æ¢è¡Œç¬¦è¢«æ¸²æŸ“æˆç©ºç™½ */
            border-radius: 8px;
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--glass-border);
            font-family: var(--font-serif);
        }
        #readerBody {
            white-space: pre-wrap; /* ä»…æ­£æ–‡ä¿ç•™æ¢è¡Œå’Œç©ºæ ¼ */
        }
        /* ç´§å‡‘å¸ƒå±€ä¼˜åŒ– */
        .reader-content p { margin: 0.4em 0; } /* æ­£æ–‡æ®µè½é—´è·ï¼šçº¦7px */
        .reader-content > div { margin-bottom: 6px !important; } /* ç»„ä»¶å‚ç›´é—´è·ï¼š6px */
        .reader-content .chapter-nav { margin-bottom: 0 !important; } /* å¯¼èˆªæ æ— ä¸‹è¾¹è· */
        .reader-content .card { margin-bottom: 6px !important; } /* è¦†ç›–å¡ç‰‡é»˜è®¤é—´è· */
        .reader-content .btn { padding: 6px 16px; font-size: 13px; } /* æŒ‰é’®ç¨å¾®ç´§å‡‘ä¸€ç‚¹ */
        
        .chapter-nav {
            display: flex; 
            justify-content: space-between; 
            margin-top: 10px; 
            padding: 10px; 
            background: rgba(255,255,255,0.4); 
            border: 1px solid rgba(0,0,0,0.05); 
            border-radius: 8px;
        }
        
        .reader-title {
            font-size: 28px; /* ä¼˜åŒ–ï¼šç¨å¾®å‡å°æ ‡é¢˜ */
            font-weight: bold;
            margin-bottom: 0.5em;
            text-align: center;
            color: var(--text-main);
            font-family: var(--font-art);
            line-height: 1.4;
        }

        /* --- ä¹¦æ¶ --- */
        .bookshelf-grid { display: flex; flex-direction: column; gap: 15px; }
        .shelf-book { 
            display: flex; 
            background: rgba(255,255,255,0.6); 
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer; 
            position: relative;
            text-align: left;
            box-shadow: none;
            transition: all 0.3s;
        }
        .shelf-book:hover {
            background: rgba(255,255,255,0.9);
            transform: translateY(-2px);
            box-shadow: var(--shadow-soft);
        }
        .shelf-book .book-cover-sm { 
            width: 70px; height: 93px; 
            background: #eee; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 10px; color: #aaa; text-align: center; 
            flex-shrink: 0; margin-right: 20px;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        }
        .shelf-book-title { font-size: 18px; font-weight: bold; color: var(--text-main); margin-bottom: 8px; font-family: var(--font-serif); }
        .shelf-book-intro { font-size: 13px; color: var(--text-sub); line-height: 1.6; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
        
        .shelf-pin-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            color: #ccc;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255,255,255,0.5);
        }
        .shelf-pin-btn:hover { transform: scale(1.2); background: rgba(255,255,255,0.8); }
        .shelf-pin-btn.active { color: #ff4d4f; }

        /* --- ä¸–ç•Œè§‚ --- */
        .setting-item { background: rgba(255,255,255,0.5); padding: 15px; border-left: 4px solid var(--jj-green); margin-bottom: 15px; border-radius: 0 8px 8px 0; }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid rgba(0,0,0,0.05); padding-bottom: 10px; }
        .btn-group { display: flex; gap: 8px; }
        .btn-sm { padding: 4px 12px; font-size: 12px; }
        .edit-mode-box { border: 1px dashed var(--jj-green); padding: 15px; background: rgba(255,255,255,0.8); margin-bottom: 15px; border-radius: 8px; }
        
        /* --- å…¶ä»–ç»„ä»¶ --- */
        .author-say-header { 
            background: transparent; 
            color: var(--jj-green); 
            padding: 5px 0; 
            border-radius: 8px; 
            border: none;
            transition: all 0.3s;
        }
        .author-say-header:hover { opacity: 0.8; }
        .author-say-header.expanded {
            background: rgba(74, 124, 89, 0.1); 
            padding: 10px 15px; 
            border: 1px solid transparent;
        }
        .author-say-header.expanded:hover { background: rgba(74, 124, 89, 0.2); }

        .author-say-content { 
            background: rgba(255,255,255,0.8);
            padding: 10px 15px; /* ä¼˜åŒ–ï¼šå‡å°‘å†…è¾¹è· */
            border: 1px dashed var(--jj-green);
            border-radius: 8px;
            margin-top: 5px; /* ä¼˜åŒ–ï¼šå‡å°‘ä¸Šè¾¹è· */
            display: none; /* é»˜è®¤éšè— */
        }
        .author-say-content.show { display: block; }
        
        /* å‰§æƒ…å»ºè®®æ¿å—æ ·å¼ */
        .plot-suggestion-box {
            margin-top: 0;
            margin-bottom: 5px !important; /* å¼ºåˆ¶è¦†ç›– card çš„ margin-bottom */
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            transition: all 0.3s;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        .plot-suggestion-box.expanded {
            background: #f9f9f9;
            border: 1px solid #eee;
            padding: 24px;
            border-radius: 16px;
        }

        .comment-section { 
            margin-top: 0 !important; 
            padding: 10px; 
            background: rgba(255,255,255,0.4);
            border: 1px solid rgba(0,0,0,0.05);
            border-top: none;
            border-radius: 0 0 8px 8px;
        }
        .comment-section h4 { margin: 0 0 8px 0 !important; font-size: 14px; }
        .comment-item { margin-bottom: 0; border-bottom: 1px solid rgba(0,0,0,0.03); padding: 6px 0; font-size: 13px; line-height: 1.5; }
        #commentList {
            height: 200px; /* å›ºå®šé«˜åº¦ */
            overflow-y: auto;
            background: rgba(255,255,255,0.5);
            border-radius: 6px;
            padding: 8px;
            border: 1px solid rgba(0,0,0,0.05);
            margin-bottom: 8px;
        }
        #commentList::-webkit-scrollbar { width: 4px; }
        #commentList::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 2px; }
        .comment-user-name { color: #666; font-weight: bold; }
        .abandoned-chapter-row { background: rgba(0,0,0,0.02); border-bottom: 1px solid rgba(0,0,0,0.05); }

        /* ç›®å½•å¼¹çª— - å·¦ä¾§æŠ½å±‰å¼ */
        .catalog-modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); backdrop-filter: blur(2px);
            z-index: 2000; display: none; 
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
        .catalog-modal.active { opacity: 1; pointer-events: auto; }
        .catalog-content { 
            width: 300px; height: 100%;
            background: rgba(255, 255, 255, 0.98); 
            backdrop-filter: blur(20px);
            box-shadow: 5px 0 20px rgba(0,0,0,0.1);
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; flex-direction: column;
        }
        .catalog-modal.active .catalog-content { transform: translateX(0); }
        .catalog-header { padding: 20px; border-bottom: 1px solid rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: center; }
        .catalog-list { flex: 1; overflow-y: auto; padding: 10px 0; }
        .catalog-item { padding: 12px 20px; cursor: pointer; font-size: 14px; border-bottom: 1px solid rgba(0,0,0,0.03); transition: background 0.2s; }
        .catalog-item:hover { background: rgba(74, 124, 89, 0.1); }
        .catalog-item.active { color: var(--jj-green); font-weight: bold; background-color: rgba(74, 124, 89, 0.15); border-left: 4px solid var(--jj-green); }
        .catalog-item.abandoned { color: #999; font-size: 13px; font-style: italic; }

        /* Tabs */
        .world-tabs { border-bottom: 1px solid rgba(0,0,0,0.1); background: transparent; border-radius: 0; margin-bottom: 20px; display: flex; gap: 20px; overflow-x: auto; }
        .world-tab-item { background: transparent; color: var(--text-sub); border-right: none; border-bottom: 2px solid transparent; font-family: var(--font-serif); font-weight: 600; padding: 10px 5px; cursor: pointer; white-space: nowrap; }
        .world-tab-item.active { background: transparent; color: var(--jj-green); border-bottom: 2px solid var(--jj-green); }
        .world-tab-item:hover { color: var(--jj-green); }

        /* æ ‡ç­¾æ ·å¼ */
        .tag-list-container { display: flex; flex-wrap: wrap; gap: 8px; }
        .world-tag-item { 
            display: inline-flex; align-items: center; gap: 6px;
            background: rgba(255,255,255,0.6); 
            color: var(--jj-green); 
            border: 1px solid var(--jj-green);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            padding: 6px 14px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            width: auto;
            font-size: 14px;
        }
        .world-tag-item:hover { background: var(--jj-green); color: white; }
        .world-tag-close { font-weight: bold; opacity: 0.6; padding-left: 4px; }
        .world-tag-close:hover { opacity: 1; }

        /* å¢å¤§è¾“å…¥æ¡† */
        .large-input { padding: 15px; font-size: 16px; }
        .large-textarea { min-height: 200px; font-size: 15px; }

        /* åˆ—è¡¨å†…å®¹æ‘˜è¦æ˜¾ç¤º */
        .setting-content {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            line-height: 1.6;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            max-height: 4.8em;
        }

        /* --- æ‚¬æµ®æŒ‰é’®ä¸é¢æ¿ --- */
        .floating-menu-container {
            position: fixed;
            bottom: 120px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 900;
        }
        
        .float-sub-btns {
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 5px;
        }
        
        .float-sub-btns.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .float-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--jj-green);
            color: var(--jj-green);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: var(--font-serif);
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            touch-action: manipulation; /* ä¼˜åŒ–è§¦æ§ */
        }
        .float-btn:hover, .float-btn:active {
            transform: scale(1.1);
            background: var(--jj-green);
            color: white;
            box-shadow: 0 6px 15px rgba(74, 124, 89, 0.3);
        }
        .float-btn.main-btn {
            width: 55px;
            height: 55px;
            font-size: 20px;
            background: var(--jj-green);
            color: white;
            border: 2px solid white;
            box-shadow: 0 6px 20px rgba(74, 124, 89, 0.4);
            z-index: 902;
        }
        .float-btn.main-btn.active {
            transform: rotate(45deg);
            background: #ff4d4f;
        }
        .float-btn.has-content::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 10px;
            height: 10px;
            background: #ff4d4f;
            border-radius: 50%;
            border: 2px solid #fff;
        }
        
        .float-panel {
            position: fixed;
            bottom: 120px;
            right: 90px;
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.8);
            z-index: 901;
            display: none;
            animation: fade-in-right 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .float-panel.active { display: block; }
        
        @keyframes fade-in-right {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* --- é¢„è®¾ç®¡ç†å¡ç‰‡æ ·å¼ --- */
        .preset-card {
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            margin-bottom: 10px;
            background: rgba(255,255,255,0.5);
            overflow: hidden;
            transition: all 0.3s;
        }
        .preset-header {
            padding: 12px 15px;
            background: rgba(0,0,0,0.02);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        .preset-header:hover {
            background: rgba(0,0,0,0.05);
        }
        .preset-title {
            font-weight: bold;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .preset-arrow {
            transition: transform 0.3s;
            font-size: 12px;
            color: #999;
            margin-right: 5px;
            display: inline-block;
        }
        .preset-card.expanded .preset-arrow {
            transform: rotate(90deg);
        }
        .preset-body {
            display: none;
            padding: 15px;
            border-top: 1px solid rgba(0,0,0,0.05);
            background: rgba(255,255,255,0.3);
            max-height: 500px;
            overflow-y: auto;
        }
        .preset-body::-webkit-scrollbar { width: 4px; }
        .preset-body::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 2px; }
        .preset-card.expanded .preset-body {
            display: block;
            animation: fadeIn 0.3s;
        }
        /* æ‹–æ‹½æ’åºæ ·å¼ */
        .entry-card.dragging {
            opacity: 0.4;
            border: 2px dashed var(--jj-green);
            background: #f0f9f4;
        }
        .entry-card.drag-over {
            border: 2px solid var(--jj-green);
        }
        .drag-handle {
            cursor: grab;
            color: #aaa;
            margin-right: 5px;
            font-size: 14px;
            user-select: none;
            padding: 0 5px;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .regex-list {
            margin-top: 10px;
            border: 1px dashed rgba(0,0,0,0.1);
            border-radius: 6px;
            padding: 10px;
            background: rgba(255,255,255,0.4);
        }
        .regex-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            font-size: 13px;
        }
        .regex-item:last-child {
            border-bottom: none;
        }
        .regex-info {
            flex: 1;
            margin-right: 10px;
            overflow: hidden;
        }
        .regex-name { font-weight: bold; color: var(--jj-green); display: block; margin-bottom: 2px; }
        .regex-desc { color: #888; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* --- é¢„è®¾æ¡ç›®åŒ–æ ·å¼ --- */
        .entry-list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .entry-card { background: rgba(255,255,255,0.6); border: 1px solid rgba(0,0,0,0.05); border-radius: 6px; overflow: hidden; transition: all 0.2s; }
        .entry-header { padding: 8px 12px; background: rgba(0,0,0,0.02); display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-size: 13px; user-select: none; }
        .entry-header:hover { background: rgba(0,0,0,0.05); }
        .entry-title { font-weight: 600; color: var(--text-main); display: flex; align-items: center; gap: 8px; flex: 1; }
        .entry-arrow { transition: transform 0.2s; font-size: 10px; color: #999; }
        .entry-card.expanded .entry-arrow { transform: rotate(90deg); }
        .entry-body { padding: 10px; display: none; border-top: 1px solid rgba(0,0,0,0.05); background: rgba(255,255,255,0.4); }
        .entry-card.expanded .entry-body { display: block; animation: fadeIn 0.2s; }
        .entry-textarea { width: 100%; border: 1px solid rgba(0,0,0,0.1); background: rgba(255,255,255,0.5); border-radius: 4px; padding: 8px; font-size: 13px; font-family: monospace; resize: vertical; min-height: 80px; }
        .entry-textarea:focus { background: #fff; border-color: var(--jj-green); outline: none; }

        /* --- ç§»åŠ¨ç«¯å…¨å±é€‚é… --- */
        @media screen and (max-width: 768px) {
            .container {
                padding: 12px;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            /* é¦–é¡µ/åˆ—è¡¨é¡µå¡ç‰‡ç´§å‡‘åŒ– */
            .card {
                padding: 16px;
                margin-bottom: 16px;
                border-radius: 12px;
            }

            /* é˜…è¯»å™¨é¡µé¢å…¨å±æ²‰æµ¸ */
            #reader.container {
                padding: 0;
            }
            
            .reader-content {
                border-radius: 0;
                border: none;
                box-shadow: none;
                min-height: 100vh;
                padding: 20px 18px 120px 18px; /* åº•éƒ¨ç•™ç™½ç»™å¯¼èˆª */
                margin-bottom: 0;
            }
            
            /* å¯¼èˆªæ è°ƒæ•´ */
            .navbar {
                width: 92%;
                bottom: 15px;
                padding: 10px 0;
                border-radius: 40px;
            }
            
            /* å­—ä½“è°ƒæ•´ */
            .header-logo {
                font-size: 32px;
                margin-top: 30px;
            }
            
            /* æ‚¬æµ®é¢æ¿é€‚é… */
            .float-panel {
                right: 15px;
                left: 15px;
                width: auto;
                bottom: 100px;
            }
            
            .floating-menu-container {
                right: 15px;
                bottom: 100px;
            }

            /* ç›®å½•ä¾§è¾¹æ  */
            .catalog-content {
                width: 80%;
            }
        }

    </style>
</head>
<body>
    <div id="app-background"></div>
    <div id="app-mask"></div>

    <nav class="navbar" id="mainNav">
        <div class="nav-item active" onclick="navTo('home')">
            <span class="nav-icon">âœ¨</span>åˆ›ä½œ
        </div>
        <div class="nav-item" onclick="navTo('bookshelf')">
            <span class="nav-icon">ğŸ“š</span>ä¹¦æ¶
        </div>
        <div class="nav-item" onclick="navTo('world')">
            <span class="nav-icon">ğŸŒ</span>ä¸–ç•Œè§‚
        </div>
        <div class="nav-item" onclick="navTo('settings')">
            <span class="nav-icon">âš™ï¸</span>è®¾ç½®
        </div>
    </nav>

    <div id="home" class="page active container">
        <header>
            <h1 class="header-logo">æŠ˜é£æ–‡å­¦åŸ</h1>
            <p class="header-subtitle">å‡¡äººç™¾å¹´ï¼Œçˆ±æ˜¯ç§©åºå¤–çš„ä¸€ç¬é—´</p>
        </header>
        
        <div class="card">
            <div class="input-group">
                <div class="search-wrapper" onclick="document.getElementById('realSearchInput').focus()">
                    <div id="selectedTagsContainer" style="display:contents"></div>
                    <input type="text" id="realSearchInput" class="search-input-field" placeholder="è¾“å…¥å…³é”®è¯ã€æ¢—æ¦‚ï¼Œæˆ–ç‚¹å‡»ä¸‹æ–¹æ ‡ç­¾..." oninput="filterHomeTags()">
                </div>
            </div>
            
            <div class="tag-cloud" id="homeTagCloud">
                <!-- æ ‡ç­¾å°†ç”± JS åŠ¨æ€æ¸²æŸ“ -->
            </div>
            
            <div style="margin-top: 15px; text-align: right;">
                <button class="btn btn-jj" onclick="startNewGeneration()">âœ¨ å¸®æˆ‘å†™æ–‡æ¡ˆ</button>
            </div>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center; margin-top: 20px; margin-bottom: 10px;">
            <h3 style="margin:0;">ğŸ“š æ–°ä¹¦é€Ÿé€’</h3>
            <div class="btn-group">
                <button class="btn btn-sm btn-jj" id="filterBtnMix" onclick="setHomeFilter('mix')">æ··åˆ</button>
                <button class="btn btn-sm btn-outline" id="filterBtnShort" onclick="setHomeFilter('short')">çŸ­æ–‡</button>
                <button class="btn btn-sm btn-outline" id="filterBtnLong" onclick="setHomeFilter('long')">é•¿æ–‡</button>
            </div>
        </div>
        <div id="generatedResults">
            <div style="text-align: center; color: #999; padding: 20px;">
                æš‚æ— ç”Ÿæˆè®°å½•ï¼Œè¯·åœ¨ä¸Šæ–¹è¾“å…¥çµæ„Ÿ...
            </div>
        </div>
        
        <div id="paginationControls" class="pagination-container" style="display:none;">
            <button class="btn btn-outline" id="btnPrev" onclick="changePage(-1)">ä¸Šä¸€é¡µ</button>
            <span class="page-num" id="pageIndicator">ç¬¬ 1 é¡µ</span>
            <button class="btn btn-jj" id="btnNext" onclick="generateNextPage()">ä¸‹ä¸€é¡µ ></button>
        </div>
    </div>

    <div id="detail" class="page container">
        <button class="btn btn-outline" id="btnBackToBookList" onclick="navTo('home')" style="margin-bottom: 15px;">&larr; è¿”å›åˆ—è¡¨</button>
        
        <div class="card" id="bookDetailContent">
            </div>

        <div class="card">
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-jj" style="flex:1" onclick="addToShelf()">æ”¶è—æ­¤ä¹¦</button>
                <button class="btn btn-outline" id="btnStartRead" style="flex:1" onclick="startReading(1)">å¼€å§‹é˜…è¯»</button>
            </div>
        </div>

        <div class="card">
            <h4 style="margin-top:0; color:var(--jj-green);">ç« èŠ‚ç›®å½•</h4>
            <div class="jj-chapter-list" id="chapterList">
                </div>
        </div>
    </div>

    <div id="reader" class="page container">
        <div class="reader-header">
            <div style="display:flex; gap:10px;">
                <button class="btn btn-outline" onclick="navTo('detail')">&larr; è¯¦æƒ…</button>
                <button class="btn btn-outline" onclick="toggleReaderCatalog()">ğŸ“– ç›®å½•</button>
            </div>
            <button class="btn btn-danger" onclick="regenerateCurrentChapter()">â†» é‡æ–°ç”Ÿæˆ</button>
        </div>
        
        <!-- é˜…è¯»é¡µç›®å½•å¼¹çª— -->
        <div id="readerCatalogModal" class="catalog-modal" onclick="if(event.target===this) toggleReaderCatalog()">
            <div class="catalog-content">
                <div class="catalog-header">
                    <h3 style="margin:0; color:var(--jj-green);">ç« èŠ‚ç›®å½•</h3>
                    <button class="btn" onclick="toggleReaderCatalog()" style="font-size:20px; padding:0 10px;">Ã—</button>
                </div>
                <div id="readerCatalogList" class="catalog-list"></div>
            </div>
        </div>
        
        <div class="reader-content">
            <div id="readerTitle" class="reader-title"></div>
            <div id="readerBody"></div>
            <div style="text-align: right; margin-top: 0; margin-bottom: 0;">
                <span class="edit-btn" onclick="toggleEditBody(this)">âœï¸ ä¿®æ”¹æ­£æ–‡</span>
            </div>
            
            <!-- å¯¼èˆªæŒ‰é’® (ç§»å…¥) -->
            <div class="chapter-nav">
                <button class="btn btn-outline" id="btnPrevChapter" onclick="prevChapter()">ä¸Šä¸€ç« </button>
                <button class="btn btn-danger btn-sm" onclick="deleteCurrentChapter()" style="margin: 0 10px;">ğŸ—‘ï¸ åˆ é™¤æœ¬ç« </button>
                <button class="btn btn-jj" id="btnNextChapter" onclick="nextChapter()">ä¸‹ä¸€ç«  (ä½œå®¶ç¿»ç‚’)</button>
            </div>

            <!-- ä½œè€…æœ‰è¯è¯´æ¿å— -->
            <div class="card" id="panelAuthor" style="margin-top: 15px; display:none; border: 1px dashed var(--jj-green); background: rgba(74, 124, 89, 0.05);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                    <h4 style="margin:0; color:var(--jj-green);">ğŸ“¢ ä½œè€…æœ‰è¯è¯´</h4>
                    <span class="edit-btn" onclick="toggleEditAuthorSay(this)" title="ä¿®æ”¹" style="cursor:pointer;">âœï¸</span>
                </div>
                <div style="font-size:12px; color:#666; margin-bottom:8px; padding-bottom:8px; border-bottom:1px dashed rgba(0,0,0,0.05);">
                    è§„èŒƒï¼šä»…å‘å¸ƒæƒ…èŠ‚æ¢³ç†ã€äººç‰©è¯„ä»·ã€ä¸‹ç« é¢„å‘Šã€‚ä¸è®¡å…¥æ­£æ–‡å­—æ•°ã€‚
                </div>
                <div id="authorSayContent" class="author-say-content" style="display:block; margin-top:0; border:none; background:transparent; padding:0;"></div>
            </div>

            <!-- è¯»è€…è¯„è®ºæ¿å— -->
            <div class="card" id="panelComment" style="margin-top: 15px;">
                <h4 style="margin:0 0 10px 0; color:var(--jj-green);">ğŸ“ è¯»è€…è¯„è®º</h4>
                <div id="commentList" style="height: auto; max-height: 500px; overflow-y: auto; margin-bottom: 10px; border: 1px solid #eee; padding: 5px; border-radius: 4px;"></div>
                <div class="comment-action" style="text-align: center;">
                    <button class="btn btn-outline btn-sm" onclick="loadMoreComments()" style="width:100%">æŸ¥çœ‹æ›´å¤šè¯„è®º</button>
                </div>
            </div>

            <!-- æ‚¬æµ®èœå•å®¹å™¨ -->
            <div class="floating-menu-container" id="readerFloatMenu" style="display:none;">
                <div class="float-sub-btns" id="floatSubBtns">
                    <div class="float-btn" id="btnFloatPlot" onclick="toggleFloatPanel('plot')" title="å‰§æƒ…å»ºè®®">å‰§</div>
                    <div class="float-btn" id="btnFloatWordCount" onclick="toggleFloatPanel('wordcount')" title="å­—æ•°ç›®æ ‡">å­—</div>
                    <div class="float-btn" id="btnFloatSummary" onclick="toggleFloatPanel('summary')" title="æœ¬ç« æ‘˜è¦">æ‘˜</div>
                </div>
                <div class="float-btn main-btn" onclick="toggleFloatMenu()">ç« </div>
            </div>

            <!-- æ‚¬æµ®é¢æ¿ï¼šå‰§æƒ…å»ºè®® -->
            <div class="float-panel" id="panelPlot">
                <h4 style="margin:0 0 10px 0; color:var(--jj-green);">ğŸ”® ä¸‹ä¸€ç« å‰§æƒ…å»ºè®®</h4>
                <textarea id="plotSuggestion" rows="5" style="width:100%; font-size:14px;" placeholder="æƒ³çœ‹è¿½å¦»ç«è‘¬åœºï¼Ÿè¿˜æ˜¯ç»åœ°åå‡»ï¼Ÿå‘Šè¯‰AIä½ çš„æƒ³æ³•..."></textarea>
            </div>

            <!-- æ‚¬æµ®é¢æ¿ï¼šå­—æ•°ç›®æ ‡ -->
            <div class="float-panel" id="panelWordcount">
                <h4 style="margin:0 0 10px 0; color:var(--jj-green);">ğŸ“ æœ€ä½å­—æ•°ç›®æ ‡</h4>
                <div class="input-group" style="margin-bottom: 0; display: flex; align-items: center; gap: 10px;">
                    <input type="number" id="minWordCount" value="3000" step="100" min="100" style="width: 100px;" onchange="saveWordCountSetting()">
                    <span style="font-size: 12px; color: #999;">(å®æ—¶ç”Ÿæ•ˆ)</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top:8px; line-height:1.4;">
                    * å…¨å±€å½±å“åç»­æ‰€æœ‰ç« èŠ‚<br>
                    * ä»…é™åˆ¶æ­£æ–‡å­—æ•°ï¼Œä¸å«ä½œè¯/è¯„è®º
                </div>
            </div>

            <!-- æ‚¬æµ®é¢æ¿ï¼šæœ¬ç« æ‘˜è¦ -->
            <div class="float-panel" id="panelSummary">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 10px;">
                    <h4 style="margin:0; color:var(--jj-green);">ğŸ“ æœ¬ç« æ‘˜è¦</h4>
                    <div style="display:flex; gap:5px;">
                        <button class="btn btn-outline btn-sm" onclick="autoGenerateSummary()" style="font-size:12px;">æ€»ç»“æœ¬ç« </button>
                        <button class="btn btn-jj btn-sm" onclick="generateFullSummary()" style="font-size:12px;">æ€»ç»“å‰æ–‡</button>
                    </div>
                </div>
                <textarea id="chapterSummary" rows="8" style="width:100%; font-size:13px;" placeholder="- æ—¶é—´:\n  - å…³é”®äº‹ä»¶: ..." oninput="saveChapterSummary()"></textarea>
            </div>
        </div>
    </div>

    <div id="bookshelf" class="page container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3>æˆ‘çš„æ”¶è—</h3>
            <div style="display: flex; gap: 5px;">
                <input type="file" id="importFileTxt" style="display:none" onchange="importData(this)" accept=".txt">
                <input type="file" id="importFileJson" style="display:none" onchange="importData(this)" accept=".json">
                <button class="btn btn-outline" onclick="document.getElementById('importFileTxt').click()">å¯¼å…¥TXT</button>
                <button class="btn btn-outline" onclick="document.getElementById('importFileJson').click()">å¯¼å…¥JSON</button>
                <button class="btn btn-outline" onclick="toggleBatchMode()" id="btnBatchMode">æ‰¹é‡ç®¡ç†</button>
            </div>
        </div>

        <div id="batchActions" style="display:none; background:#fff; padding:10px; margin-bottom:15px; border-radius:8px; border:1px solid var(--jj-green);">
            <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap: wrap; gap: 10px;">
                <span>å·²é€‰: <span id="selectedCount">0</span> æœ¬</span>
                <div style="display:flex; gap:5px; flex-wrap: wrap;">
                    <button class="btn btn-outline" onclick="exportSelectedData('json')">æ‰¹é‡å¯¼å‡ºJSON</button>
                    <button class="btn btn-outline" onclick="exportSelectedData('txt')">æ‰¹é‡å¯¼å‡ºTXT</button>
                    <button class="btn btn-danger" onclick="deleteSelectedBooks()">æ‰¹é‡åˆ é™¤</button>
                </div>
            </div>
        </div>

        <div class="input-group">
            <input type="text" id="shelfSearch" placeholder="æœç´¢ä¹¦å/æ ‡ç­¾..." oninput="renderShelf()">
        </div>

        <div class="bookshelf-grid" id="shelfGrid">
            </div>
    </div>

    <div id="world" class="page container">
        <h3>ğŸŒ ä¸–ç•Œè§‚ä¸è®¾å®šç®¡ç†</h3>
        
        <div class="world-tabs">
            <div class="world-tab-item active" data-tab="character" onclick="switchWorldTab('character')">è§’è‰²è®¾å®š</div>
            <div class="world-tab-item" data-tab="func_worldbook" onclick="switchWorldTab('func_worldbook')">åŠŸèƒ½ä¸–ç•Œä¹¦</div>
            <div class="world-tab-item" data-tab="worldbook" onclick="switchWorldTab('worldbook')">æ ‡ç­¾ä¸–ç•Œä¹¦</div>
            <div class="world-tab-item" data-tab="tag" onclick="switchWorldTab('tag')">æ ‡ç­¾åŠŸèƒ½</div>
        </div>

        <!-- è§’è‰²è®¾å®šåŒºåŸŸ -->
        <div id="tab_content_character" class="world-tab-content">
            <div class="card">
                <div class="section-header">
                    <h4 style="margin:0">ğŸ‘¤ è§’è‰²è®¾å®š</h4>
                    <div class="btn-group">
                        <button class="btn btn-outline btn-sm" onclick="toggleWorldBatchMode('character')" id="btn_batch_character">æ‰¹é‡ç®¡ç†</button>
                        <button class="btn btn-outline btn-sm" onclick="triggerImport('character', 'json')">å¯¼å…¥JSON</button>
                        <button class="btn btn-outline btn-sm" onclick="triggerImport('character', 'txt')">å¯¼å…¥TXT</button>
                        <button class="btn btn-outline btn-sm" onclick="exportWorldData('character')">å¯¼å‡ºå…¨éƒ¨</button>
                        <button class="btn btn-danger btn-sm" onclick="clearWorldData('character')">æ¸…ç©º</button>
                    </div>
                </div>
                <!-- æ‰¹é‡æ“ä½œæ  -->
                <div id="batch_actions_character" style="display:none; background:#f9f9f9; padding:10px; margin-bottom:15px; border-radius:8px; border:1px solid var(--jj-green);">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:13px;">å·²é€‰: <span id="selected_count_character">0</span> é¡¹</span>
                        <div style="display:flex; gap:5px;">
                            <button class="btn btn-sm btn-outline" onclick="exportSelectedWorldData('character')">å¯¼å‡ºé€‰ä¸­</button>
                            <button class="btn btn-sm btn-danger" onclick="deleteSelectedWorldItems('character')">åˆ é™¤é€‰ä¸­</button>
                        </div>
                    </div>
                </div>
                <!-- æ–°å»ºè¡¨å• -->
                <div class="add-form">
                    <div class="input-group">
                        <input type="text" id="new_character_name" class="large-input" placeholder="è§’è‰²å (å¦‚: æ—é»›ç‰)">
                    </div>
                    <div class="input-group">
                        <textarea id="new_character_desc" class="large-textarea" rows="5" placeholder="è§’è‰²æè¿°/äººè®¾/æ€§æ ¼/å¤–è²Œ"></textarea>
                    </div>
                    <button class="btn btn-jj" style="width:100%" onclick="addWorldItem('character')">æ–°å¢è§’è‰²</button>
                </div>
                <!-- åˆ—è¡¨ -->
                <div id="list_character" class="setting-list"></div>
            </div>
        </div>

        <!-- åŠŸèƒ½ä¸–ç•Œä¹¦åŒºåŸŸ -->
        <div id="tab_content_func_worldbook" class="world-tab-content" style="display:none">
            <div class="card">
                <div class="section-header">
                    <h4 style="margin:0">ğŸ§© åŠŸèƒ½ä¸–ç•Œä¹¦</h4>
                    <div class="btn-group">
                        <button class="btn btn-outline btn-sm" onclick="toggleWorldBatchMode('func_worldbook')" id="btn_batch_func_worldbook">æ‰¹é‡ç®¡ç†</button>
                        <button class="btn btn-outline btn-sm" onclick="triggerImport('func_worldbook', 'json')">å¯¼å…¥JSON</button>
                        <button class="btn btn-outline btn-sm" onclick="triggerImport('func_worldbook', 'txt')">å¯¼å…¥TXT</button>
                        <button class="btn btn-outline btn-sm" onclick="exportWorldData('func_worldbook')">å¯¼å‡ºå…¨éƒ¨</button>
                        <button class="btn btn-danger btn-sm" onclick="clearWorldData('func_worldbook')">æ¸…ç©º</button>
                    </div>
                </div>
                <div id="batch_actions_func_worldbook" style="display:none; background:#f9f9f9; padding:10px; margin-bottom:15px; border-radius:8px; border:1px solid var(--jj-green);">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:13px;">å·²é€‰: <span id="selected_count_func_worldbook">0</span> é¡¹</span>
                        <div style="display:flex; gap:5px;">
                            <button class="btn btn-sm btn-outline" onclick="exportSelectedWorldData('func_worldbook')">å¯¼å‡ºé€‰ä¸­</button>
                            <button class="btn btn-sm btn-danger" onclick="deleteSelectedWorldItems('func_worldbook')">åˆ é™¤é€‰ä¸­</button>
                        </div>
                    </div>
                </div>
                <div class="add-form">
                    <div class="input-group">
                        <input type="text" id="new_func_worldbook_name" class="large-input" placeholder="åŠŸèƒ½åç§° (å¦‚: æˆ˜æ–—ç³»ç»Ÿ, ç‚¼ä¸¹æœ¯)">
                    </div>
                    <div class="input-group">
                        <textarea id="new_func_worldbook_desc" class="large-textarea" rows="5" placeholder="è¯¦ç»†åŠŸèƒ½è§„åˆ™"></textarea>
                    </div>
                    <button class="btn btn-jj" style="width:100%" onclick="addWorldItem('func_worldbook')">æ–°å¢åŠŸèƒ½è®¾å®š</button>
                </div>
                
                <!-- åˆ—è¡¨ -->
                <div id="list_func_worldbook" class="setting-list"></div>
            </div>
        </div>

        <!-- ä¸–ç•Œä¹¦åŒºåŸŸ -->
        <div id="tab_content_worldbook" class="world-tab-content" style="display:none">
            <div class="card">
                <div class="section-header">
                    <h4 style="margin:0">ğŸ“– æ ‡ç­¾ä¸–ç•Œä¹¦</h4>
                    <div class="btn-group">
                        <button class="btn btn-outline btn-sm" onclick="toggleWorldBatchMode('worldbook')" id="btn_batch_worldbook">æ‰¹é‡ç®¡ç†</button>
                        <button class="btn btn-outline btn-sm" onclick="triggerImport('worldbook', 'json')">å¯¼å…¥JSON</button>
                        <button class="btn btn-outline btn-sm" onclick="triggerImport('worldbook', 'txt')">å¯¼å…¥TXT</button>
                        <button class="btn btn-outline btn-sm" onclick="exportWorldData('worldbook')">å¯¼å‡ºå…¨éƒ¨</button>
                        <button class="btn btn-danger btn-sm" onclick="clearWorldData('worldbook')">æ¸…ç©º</button>
                    </div>
                </div>
                <div id="batch_actions_worldbook" style="display:none; background:#f9f9f9; padding:10px; margin-bottom:15px; border-radius:8px; border:1px solid var(--jj-green);">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:13px;">å·²é€‰: <span id="selected_count_worldbook">0</span> é¡¹</span>
                        <div style="display:flex; gap:5px;">
                            <button class="btn btn-sm btn-outline" onclick="exportSelectedWorldData('worldbook')">å¯¼å‡ºé€‰ä¸­</button>
                            <button class="btn btn-sm btn-danger" onclick="deleteSelectedWorldItems('worldbook')">åˆ é™¤é€‰ä¸­</button>
                        </div>
                    </div>
                </div>
                <div class="add-form">
                    <div class="input-group">
                        <input type="text" id="new_worldbook_name" class="large-input" placeholder="æ¡ç›®åç§° (å¦‚: é­”æ³•ä½“ç³», åœ°ç†ç¯å¢ƒ)">
                    </div>
                    <div class="input-group">
                        <textarea id="new_worldbook_desc" class="large-textarea" rows="5" placeholder="è¯¦ç»†è®¾å®šè§„åˆ™"></textarea>
                    </div>
                    <button class="btn btn-jj" style="width:100%" onclick="addWorldItem('worldbook')">æ–°å¢è®¾å®š</button>
                </div>
                <div id="list_worldbook" class="setting-list"></div>
            </div>
        </div>

        <!-- æ ‡ç­¾åŒºåŸŸ -->
        <div id="tab_content_tag" class="world-tab-content" style="display:none">
            <div class="card">
                <div class="section-header">
                    <h4 style="margin:0">ğŸ·ï¸ æ ‡ç­¾</h4>
                    <div class="btn-group">
                        <button class="btn btn-outline btn-sm" onclick="triggerImport('tag')">å¯¼å…¥</button>
                        <button class="btn btn-outline btn-sm" onclick="exportWorldData('tag')">å¯¼å‡º</button>
                        <button class="btn btn-danger btn-sm" onclick="clearWorldData('tag')">æ¸…ç©º</button>
                    </div>
                </div>
                <div class="add-form">
                    <div class="input-group">
                        <input type="text" id="tagSearchInput" class="large-input" placeholder="ğŸ” ç­›é€‰æ ‡ç­¾..." oninput="renderSection('tag')" style="margin-bottom: 10px; font-size: 14px; padding: 8px;">
                        <input type="text" id="new_tag_name" class="large-input" placeholder="æ ‡ç­¾å (æ”¯æŒæ‰¹é‡ï¼Œç”¨é¡¿å·ã€åˆ†éš”)">
                    </div>
                    <div style="display:flex; gap:10px;">
                        <button id="btn_add_tag" class="btn btn-jj" style="flex:1" onclick="addWorldItem('tag')">æ–°å¢æ ‡ç­¾</button>
                        <button id="btn_cancel_tag" class="btn btn-outline" style="display:none;" onclick="cancelTagEdit()">å–æ¶ˆ</button>
                    </div>
                </div>
                
                <h5 style="margin:15px 0 5px 0; color:#666; font-size:13px;">å…¨å±€æ ‡ç­¾åº“</h5>
                <div id="list_tag" class="setting-list tag-list-container"></div>
            </div>
        </div>

        <!-- éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† -->
        <input type="file" id="import_character_json" style="display:none" accept=".json" onchange="handleImport(this, 'character', 'json')">
        <input type="file" id="import_character_txt" style="display:none" accept=".txt" onchange="handleImport(this, 'character', 'txt')">
        
        <input type="file" id="import_worldbook_json" style="display:none" accept=".json" onchange="handleImport(this, 'worldbook', 'json')">
        <input type="file" id="import_worldbook_txt" style="display:none" accept=".txt" onchange="handleImport(this, 'worldbook', 'txt')">
        
        <input type="file" id="import_func_worldbook_json" style="display:none" accept=".json" onchange="handleImport(this, 'func_worldbook', 'json')">
        <input type="file" id="import_func_worldbook_txt" style="display:none" accept=".txt" onchange="handleImport(this, 'func_worldbook', 'txt')">
        
        <input type="file" id="import_tag" style="display:none" accept=".json" onchange="handleImport(this, 'tag', 'json')">
    </div>

    <div id="settings" class="page container">
        <h3>âš™ï¸ ç³»ç»Ÿè®¾ç½®</h3>
        
        <!-- ç•Œé¢å¤–è§‚è®¾ç½® -->
        <div class="card">
            <h4>ğŸ¨ ç•Œé¢å¤–è§‚</h4>
            
            <!-- èƒŒæ™¯è®¾ç½® -->
            <div class="input-group">
                <label>èƒŒæ™¯å›¾ç‰‡</label>
                <div style="display:flex; gap:10px; align-items:center;">
                    <button class="btn btn-outline" onclick="document.getElementById('bgUpload').click()">ä¸Šä¼ å›¾ç‰‡</button>
                    <input type="file" id="bgUpload" style="display:none" accept="image/*" onchange="handleBgUpload(this)">
                    <button class="btn btn-danger btn-sm" onclick="resetBg()">é‡ç½®é»˜è®¤</button>
                </div>
                <div style="margin-top:15px;">
                    <label style="font-size:12px; display:flex; justify-content:space-between;">
                        <span>èƒŒæ™¯æ¨¡ç³Šåº¦</span>
                        <span id="blurVal">0px</span>
                    </label>
                    <input type="range" id="bgBlur" min="0" max="20" value="0" style="width:100%" oninput="updateAppearancePreview()">
                </div>
                <div style="margin-top:5px;">
                    <label style="font-size:12px; display:flex; justify-content:space-between;">
                        <span>é®ç½©æµ“åº¦</span>
                        <span id="maskVal">0%</span>
                    </label>
                    <input type="range" id="bgMask" min="0" max="90" value="0" style="width:100%" oninput="updateAppearancePreview()">
                </div>
            </div>

            <!-- æ·±è‰²æ¨¡å¼ -->
            <div class="input-group" style="display:flex; justify-content:space-between; align-items:center; border-top: 1px dashed #eee; padding-top: 15px; margin-top: 15px;">
                <label style="margin:0">ğŸŒ™ å…¨å±€æ·±è‰²æ¨¡å¼</label>
                <label class="switch">
                    <input type="checkbox" id="darkModeSwitch" onchange="toggleDarkMode()">
                    <span class="slider round"></span>
                </label>
            </div>

            <!-- å­—ä½“è®¾ç½® -->
            <div class="input-group" style="border-top: 1px dashed #eee; padding-top: 15px; margin-top: 15px;">
                <label>å…¨å±€å­—ä½“</label>
                <div style="display:flex; gap:10px;">
                    <select id="fontSelect" style="flex:1" onchange="changeFont()">
                        <option value="default">é»˜è®¤å­—ä½“</option>
                        <!-- åŠ¨æ€æ·»åŠ è‡ªå®šä¹‰å­—ä½“ -->
                    </select>
                    <button class="btn btn-danger" onclick="deleteCustomFont()" title="åˆ é™¤å½“å‰é€‰ä¸­çš„å­—ä½“">ğŸ—‘ï¸</button>
                    <button class="btn btn-outline" onclick="document.getElementById('fontUpload').click()">æœ¬åœ°ä¸Šä¼ </button>
                    <input type="file" id="fontUpload" style="display:none" accept=".ttf,.otf,.woff,.woff2" onchange="handleFontUpload(this)">
                </div>
                
                <div style="display:flex; gap:10px; margin-bottom: 5px;">
                    <input type="text" id="externalFontUrl" placeholder="å­—ä½“URL (.ttf) æˆ– CSSé“¾æ¥ (@import/https://...)" style="flex:2">
                    <input type="text" id="externalFontName" placeholder="å­—ä½“åç§° (å¦‚: MyFont)" style="flex:1">
                    <button class="btn btn-jj" onclick="addExternalFont()">ä¿å­˜/æ›´æ–°ç½‘ç»œå­—ä½“</button>
                </div>
                <p style="font-size:12px; color:#999; margin:5px 0 15px 0;">æ”¯æŒæœ¬åœ° ttf/otf/woffï¼Œæˆ–ç½‘ç»œå­—ä½“ URLã€CSS @importã€‚é€‰ä¸­å­—ä½“åå¯åœ¨æ­¤ä¿®æ”¹é“¾æ¥ã€‚</p>

                <!-- å…¨å±€å­—ä½“å¤§å°æ»‘å— -->
                <div style="margin-top:10px; border-top: 1px dashed #eee; padding-top: 10px;">
                    <label style="display:flex; justify-content:space-between;">
                        <span>å…¨å±€å­—ä½“å¤§å°</span>
                        <span id="fontSizeVal">16px</span>
                    </label>
                    <input type="range" id="fontSizeSlider" min="12" max="30" value="16" step="1" style="width:100%" oninput="changeFontSize()">
                </div>
            </div>

            <!-- ä¸»é¢˜ç®¡ç† -->
            <div class="input-group" style="border-top: 1px dashed #eee; padding-top: 15px; margin-top: 15px;">
                <label>ä¸»é¢˜é¢„è®¾ç®¡ç†</label>
                <div style="display:flex; gap:10px; margin-bottom:10px;">
                    <select id="themeSelect" style="flex:1" onchange="loadTheme()">
                        <option value="">-- é€‰æ‹©ä¸»é¢˜ --</option>
                    </select>
                </div>
                <div style="display:flex; gap:10px;">
                    <button class="btn btn-jj" style="flex:1" onclick="saveCurrentTheme()">ğŸ’¾ ä¿å­˜å½“å‰ä¸»é¢˜</button>
                    <button class="btn btn-danger" style="flex:1" onclick="deleteTheme()">ğŸ—‘ï¸ åˆ é™¤é€‰ä¸­</button>
                </div>
            </div>

            <!-- è‡ªå®šä¹‰ CSS ç¾åŒ– -->
            <div class="input-group" style="border-top: 1px dashed #eee; padding-top: 15px; margin-top: 15px;">
                <label>å…¨å±€ç¾åŒ– (è‡ªå®šä¹‰ CSS)</label>
                <textarea id="customCSSInput" rows="6" placeholder="/* åœ¨æ­¤è¾“å…¥ CSS ä»£ç è¿›è¡Œå…¨å±€ç¾åŒ– */
/* ç¤ºä¾‹æ¨¡æ¿ï¼š */
/* body { background-color: #fdfbf7; } */
/* .card { border-radius: 20px; } */" style="font-family: monospace; font-size: 12px; background: rgba(0,0,0,0.03);"></textarea>
                <div style="display:flex; gap:10px; margin-top: 10px;">
                    <button class="btn btn-jj" style="flex:1" onclick="saveAndApplyCSS()">ğŸ’¾ ä¿å­˜å¹¶åº”ç”¨ç¾åŒ–</button>
                    <button class="btn btn-outline" onclick="document.getElementById('cssUpload').click()">ğŸ“‚ ä¸Šä¼  CSS</button>
                    <input type="file" id="cssUpload" style="display:none" accept=".css" onchange="handleCSSUpload(this)">
                </div>
            </div>
        </div>
        
        <!-- å…¨å±€æ•°æ®ç®¡ç† -->
        <div class="card">
            <h4>ğŸ’¾ å…¨å±€æ•°æ®ç®¡ç†</h4>
            <div style="background: #f9f9f9; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                <p style="font-size:13px; color:#666; margin-top:0;">å¤‡ä»½æˆ–æ¢å¤æ‰€æœ‰æ•°æ®ï¼ˆåŒ…æ‹¬ä¹¦æ¶ã€ä¸–ç•Œè§‚ã€è®¾ç½®ã€é˜…è¯»å†å²ã€è¯„è®ºç­‰ï¼‰ã€‚</p>
                <div style="display:flex; gap:10px;">
                    <button class="btn btn-jj" style="flex:1" onclick="exportGlobalData()">ğŸ“¤ å¯¼å‡ºå…¨å±€å¤‡ä»½ (.json)</button>
                    <input type="file" id="importGlobalFile" style="display:none" accept=".json" onchange="importGlobalData(this)">
                    <button class="btn btn-outline" style="flex:1" onclick="document.getElementById('importGlobalFile').click()">ğŸ“¥ å¯¼å…¥å…¨å±€å¤‡ä»½</button>
                </div>
            </div>
        </div>

        <!-- æ ¸å¿ƒæŒ‡ä»¤åŒºåŸŸ -->
        <div class="card">
            <h4>ğŸ§  æ ¸å¿ƒæŒ‡ä»¤ä¸é¢„è®¾ç®¡ç†</h4>
            
            <!-- å…¨å±€æŒ‡ä»¤ -->
            <div style="background: #f9f9f9; padding: 10px; border-radius: 4px; margin-bottom: 15px; border-left: 4px solid var(--jj-green);">
                <div class="input-group" style="margin-bottom: 10px;">
                    <label>å…¨å±€é€šç”¨æŒ‡ä»¤ (å§‹ç»ˆç”Ÿæ•ˆ)</label>
                    <textarea id="coreInstruction" rows="3" placeholder="åœ¨æ­¤è¾“å…¥å…¨å±€æŒ‡ä»¤ï¼Œä¾‹å¦‚ï¼š'æ‰€æœ‰ç”Ÿæˆå†…å®¹å¿…é¡»ç¬¦åˆæŠ˜é£æ–‡å­¦åŸå®¡æ ¸æ ‡å‡†...'"></textarea>
                </div>
                <div style="display:flex; gap:10px; justify-content: flex-end;">
                    <button class="btn btn-sm btn-jj" onclick="saveCoreInstruction()">ğŸ’¾ ä¿å­˜å…¨å±€æŒ‡ä»¤</button>
                </div>
            </div>

            <!-- é¢„è®¾åˆ—è¡¨ç®¡ç† -->
            <div class="input-group">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <label style="margin:0">é¢„è®¾é…ç½®åˆ—è¡¨ (å¯å¤šé€‰å åŠ )</label>
                    <div style="display:flex; gap:5px;">
                        <button class="btn btn-sm btn-jj" onclick="addNewPreset()">+ æ–°å»ºé¢„è®¾</button>
                        <button class="btn btn-sm btn-outline" onclick="document.getElementById('importCorePresetFile').click()">ğŸ“¥ å¯¼å…¥</button>
                        <button class="btn btn-sm btn-outline" onclick="exportCorePreset()">ğŸ“¤ å¯¼å‡º</button>
                        <input type="file" id="importCorePresetFile" style="display:none" accept=".json" onchange="importCorePreset(this)">
                    </div>
                </div>
                
                <div id="corePresetsList">
                    <!-- é¢„è®¾å¡ç‰‡å°†ç”± JS æ¸²æŸ“ -->
                </div>
                
                <!-- éšè—çš„æ­£åˆ™å¯¼å…¥ Input -->
                <input type="file" id="importRegexFile" style="display:none" accept=".json" onchange="handleRegexImport(this)">
            </div>
        </div>

        <div class="card">
            <h4>ğŸ› ï¸ æ¨¡å‹é…ç½®ç®¡ç†</h4>
            <div style="background: #f9f9f9; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                <div class="input-group">
                    <label>å·²ä¿å­˜çš„é…ç½®</label>
                    <div style="display:flex; gap:10px;">
                        <select id="savedConfigs" style="flex:1" onchange="loadSelectedConfig()">
                            <option value="">-- æ–°å»ºé…ç½® --</option>
                        </select>
                        <button class="btn btn-danger" onclick="deleteConfig()">åˆ é™¤</button>
                    </div>
                </div>
                <div class="input-group">
                    <label>é…ç½®åç§°</label>
                    <input type="text" id="configName" placeholder="ç»™å½“å‰é…ç½®èµ·ä¸ªå (å¦‚: Gemini Flash é«˜é€Ÿç‰ˆ)">
                </div>
            </div>

            <h4>å½“å‰å‚æ•°è®¾ç½®</h4>
            <div class="input-group">
                <label>æ¥å£ç±»å‹</label>
                <select id="apiTypeSelect" onchange="handleApiTypeChange()">
                    <option value="gemini">Google Gemini (é»˜è®¤)</option>
                    <option value="openai">å®˜æ–¹OpenAI</option>
                    <option value="custom_openai">è‡ªå®šä¹‰å…¼å®¹OpenAI</option>
                </select>
            </div>
            <div class="input-group">
                <label>API URL (å¯é€‰ï¼Œé»˜è®¤ä¸ºå®˜æ–¹)</label>
                <input type="text" id="apiUrl" placeholder="ä¾‹å¦‚: https://generativelanguage.googleapis.com">
            </div>
            <div class="input-group">
                <label>API Key</label>
                <input type="password" id="apiKey" placeholder="åœ¨æ­¤è¾“å…¥ä½ çš„ API Key">
                <div style="margin-top: 5px;">
                    <input type="checkbox" onchange="toggleKeyVis(this)"> æ˜¾ç¤ºKey
                </div>
            </div>
            <div class="input-group">
                <label>æ¨¡å‹é€‰æ‹©</label>
                <div style="display:flex; gap:10px;">
                    <select id="modelSelect" style="flex:1">
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                        <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                    </select>
                    <button class="btn btn-outline" onclick="fetchModels()">æ‹‰å–æ¨¡å‹</button>
                </div>
            </div>
            <div style="display:flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-jj" style="flex:1" onclick="saveConfig()">ğŸ’¾ ä¿å­˜å¹¶åº”ç”¨é…ç½®</button>
                <button class="btn btn-outline" style="flex:1" onclick="applyConfigOnly()">âš¡ ä»…ä¸´æ—¶åº”ç”¨</button>
            </div>
        </div>
    </div>

    <script>
        // ... (JsonAdapter, BookImportAdapter, toChineseNum, state, syncGlobalTags, getFullPrompt, getWorldContext, callGeminiAPI, navTo, addTag, setHomeFilter, renderHomeTags, startNewGeneration, generateNextPage, generateBatch, renderCurrentPage, changePage, mockAIResponse, showBookDetail, startReading, fetchChapterContent, mockChapterText, prevChapter, nextChapter, generateSideStory, saveWordCountSetting, regenerateCurrentChapter, readAbandonedChapter, toggleAuthorSay, toggleReaderCatalog, renderReaderCatalog, loadMoreComments, generateMockComments, renderComments, saveChapterSummary, autoGenerateSummary, updateNavButtons, addToShelf, toggleBatchMode, toggleBookSelection, deleteSelectedBooks, exportSelectedData, downloadFile, renderShelf, exportData, exportGlobalData, importGlobalData, importData, switchWorldTab, renderWorldPage, renderSection, generateRelationPoolHtml, toggleRelation, addWorldItem, editTag, addTagFromSuggestion, cancelTagEdit, deleteWorldItem, editWorldItem, cancelEdit, saveWorldItem, saveWorldData, triggerImport, handleImport, exportWorldData, clearWorldData, loadSettingsUI, loadCoreSettingsUI, renderCorePresets, saveCoreInstruction, clearCoreInstruction, saveAsCorePreset, loadCorePreset, deleteCorePreset, exportCorePreset, importCorePreset, renderConfigList, fillConfigForm, loadSelectedConfig, saveConfig, deleteConfig, applyConfigOnly, fetchModels, toggleKeyVis, toggleEditBody, toggleEditAuthorSay) ...
        
        /**
         * é€šç”¨ JSON æ•°æ®é€‚é…å™¨
         * ç”¨äºç»Ÿä¸€å¤„ç†å„ç§æ ¼å¼çš„ JSON å¯¼å…¥ï¼Œæ”¯æŒæ ¼å¼è‡ªåŠ¨è¯†åˆ«ã€å­—æ®µæ˜ å°„ã€éªŒè¯å’Œæ¸…æ´—
         */
        class JsonAdapter {
            constructor(config = {}) {
                this.fieldMapping = config.fieldMapping || {}; // { "ä¸­æ–‡å": "key" }
                this.requiredFields = config.requiredFields || [];
                this.defaultValues = config.defaultValues || {};
                this.validator = config.validator || null;
                this.name = config.name || "æ•°æ®";
            }

            parse(jsonContent) {
                let rawData;
                try {
                    rawData = typeof jsonContent === 'string' ? JSON.parse(jsonContent) : jsonContent;
                } catch (e) {
                    return { success: false, message: "JSON è¯­æ³•é”™è¯¯", details: [e.message] };
                }

                let items = [];
                let formatType = "unknown";

                // 1. æ™ºèƒ½æ ¼å¼è¯†åˆ«
                if (Array.isArray(rawData)) {
                    formatType = "ç›´æ¥æ•°ç»„ [...]";
                    items = rawData;
                } else if (typeof rawData === 'object' && rawData !== null) {
                    // ç­–ç•¥A: å¸¦å…ƒæ•°æ®çš„ç»“æ„ { data: [...], ... }
                    const listKeys = ['data', 'items', 'list', 'books', 'characters', 'settings', 'presets', 'tags', 'world', 'entries', 'roles', 'rules'];
                    // ä¼˜åŒ–ï¼šå¢åŠ å¯¹æ•°ç»„å†…å®¹çš„æ£€æŸ¥ï¼Œé¿å…å°† tags: [] æˆ– tags: ["string"] è¯¯åˆ¤ä¸ºæ•°æ®åˆ—è¡¨
                    const foundKey = listKeys.find(k => {
                        if (!Array.isArray(rawData[k])) return false;
                        if (rawData[k].length > 0) return typeof rawData[k][0] === 'object';
                        // ç©ºæ•°ç»„æ—¶ï¼Œæ’é™¤ tags/world ç­‰æ­§ä¹‰é”®ï¼Œåªä¿ç•™å¼ºåˆ—è¡¨é”®
                        return !['tags', 'world'].includes(k);
                    });
                    
                    if (foundKey) {
                        formatType = `å¸¦å…ƒæ•°æ® ({${foundKey}: [...]})`;
                        items = rawData[foundKey];
                    } 
                    // æ–°å¢ç­–ç•¥: æŸ¥æ‰¾ä»»ä½•çœ‹èµ·æ¥åƒæ•°æ®åˆ—è¡¨çš„æ•°ç»„å±æ€§ (åªè¦åŒ…å«å¯¹è±¡)
                    else {
                        const arrayKeys = Object.keys(rawData).filter(k => Array.isArray(rawData[k]) && rawData[k].length > 0 && typeof rawData[k][0] === 'object');
                        if (arrayKeys.length > 0) {
                             formatType = `è‡ªåŠ¨è¯†åˆ«æ•°ç»„å±æ€§ ({${arrayKeys.join(',')}: [...]})`;
                             arrayKeys.forEach(k => items.push(...rawData[k]));
                        }
                        // ä¼˜å…ˆç­–ç•¥: å¦‚æœå¯¹è±¡æœ¬èº«åŒ…å« name/title ä¸”æ˜¯å­—ç¬¦ä¸²ï¼Œä¼˜å…ˆè§†ä¸ºå•ä¸ªå®ä½“å¯¹è±¡
                        // (é˜²æ­¢å› åŒ…å« tags/worldIds ç­‰æ•°ç»„å±æ€§è€Œè¢«è¯¯åˆ¤ä¸ºå®¹å™¨)
                        else if ((rawData.name && typeof rawData.name === 'string') || (rawData.title && typeof rawData.title === 'string')) {
                             formatType = "å•ä¸ªå¯¹è±¡ (ä¼˜å…ˆè¯†åˆ«)";
                             items = [rawData];
                        }
                        // ç­–ç•¥B: åˆ†ç±»ç»“æ„ (æ”¾å®½æ¡ä»¶: åªè¦æ˜¯æ•°ç»„å°±æå–)
                        else if (Object.values(rawData).some(v => Array.isArray(v))) {
                            formatType = "åŒ…å«æ•°ç»„çš„ç»“æ„";
                            Object.values(rawData).forEach(v => {
                                if(Array.isArray(v)) items.push(...v);
                            });
                        }
                        // ç­–ç•¥C: å¯¹è±¡å­—å…¸ { id1: {...}, id2: {...} }
                        else if (Object.values(rawData).every(v => typeof v === 'object' && v !== null && !Array.isArray(v))) {
                            formatType = "å¯¹è±¡å­—å…¸ ({id: {...}})";
                            items = Object.values(rawData);
                        }
                        // ç­–ç•¥D: å•ä¸ªå¯¹è±¡
                        else {
                            formatType = "å•ä¸ªå¯¹è±¡ {...}";
                            items = [rawData];
                        }
                    }
                } else {
                    return { success: false, message: "ä¸æ”¯æŒçš„æ•°æ®ç»“æ„", details: ["æ— æ³•è¯†åˆ«ä¸ºæ•°ç»„æˆ–å¯¹è±¡"] };
                }

                // 2. æ•°æ®æ¸…æ´—ä¸è½¬æ¢
                const validItems = [];
                const errors = [];
                const logs = [`è¯†åˆ«åˆ°æ ¼å¼: ${formatType}`, `åŸå§‹æå–æ¡æ•°: ${items.length}`];

                items.forEach((item, idx) => {
                    if (typeof item !== 'object' || item === null) {
                        errors.push(`ç¬¬ ${idx+1} æ¡æ•°æ®æ— æ•ˆ: éå¯¹è±¡ç±»å‹`);
                        return;
                    }

                    let newItem = { ...item };

                    // å­—æ®µæ˜ å°„ (æ”¯æŒå¤šå¯¹ä¸€ï¼Œä¼˜å…ˆä¿ç•™å·²æœ‰å€¼)
                    Object.keys(this.fieldMapping).forEach(sourceKey => {
                        if (newItem[sourceKey] !== undefined) {
                            const targetKey = this.fieldMapping[sourceKey];
                            if (newItem[targetKey] === undefined || newItem[targetKey] === "") {
                                newItem[targetKey] = newItem[sourceKey];
                            }
                        }
                    });

                    // é»˜è®¤å€¼å¡«å……
                    Object.keys(this.defaultValues).forEach(key => {
                        if (newItem[key] === undefined || newItem[key] === null || newItem[key] === "") {
                            newItem[key] = this.defaultValues[key];
                        }
                    });

                    // å¿…å¡«å­—æ®µéªŒè¯
                    const missing = this.requiredFields.filter(field => 
                        newItem[field] === undefined || newItem[field] === null || String(newItem[field]).trim() === ""
                    );

                    if (missing.length > 0) {
                        errors.push(`ç¬¬ ${idx+1} æ¡æ•°æ®ç¼ºå°‘å¿…å¡«å­—æ®µ: ${missing.join(', ')}`);
                        return;
                    }

                    // è‡ªå®šä¹‰éªŒè¯å™¨
                    if (this.validator) {
                        const validationResult = this.validator(newItem);
                        if (validationResult !== true) {
                            errors.push(`ç¬¬ ${idx+1} æ¡æ•°æ®éªŒè¯å¤±è´¥: ${validationResult || 'æœªçŸ¥é”™è¯¯'}`);
                            return;
                        }
                    }

                    // è‡ªåŠ¨ç”ŸæˆID (å¦‚æœç¼ºå¤±)
                    if (!newItem.id) {
                        newItem.id = Date.now() + Math.random() + idx;
                    }

                    validItems.push(newItem);
                });

                const success = validItems.length > 0;
                return {
                    success,
                    data: validItems,
                    message: success ? `æˆåŠŸè§£æ ${validItems.length} æ¡${this.name}` : "è§£æå¤±è´¥æˆ–æ— æœ‰æ•ˆæ•°æ®",
                    details: errors.length > 0 ? errors : null,
                    logs: logs
                };
            }
        }

        /**
         * ä¹¦ç±å¯¼å…¥é€‚é…å™¨
         * ç»Ÿä¸€å¤„ç† JSON å’Œ TXT æ ¼å¼çš„ä¹¦ç±å¯¼å…¥
         */
        class BookImportAdapter {
            constructor() {
                this.jsonAdapter = new JsonAdapter({
                    name: "ä¹¦ç±",
                    fieldMapping: {
                        "ä¹¦å": "title", "name": "title",
                        "ä½œè€…": "author",
                        "ç®€ä»‹": "intro", "description": "intro", "desc": "intro",
                        "ç±»å‹": "genre", "category": "genre",
                        "å­—æ•°": "words",
                        "è¯„åˆ†": "score",
                        "çŠ¶æ€": "status",
                        "æ ‡ç­¾": "tags"
                    },
                    requiredFields: ["title"],
                    defaultValues: {
                        "author": "æœªçŸ¥ä½œè€…",
                        "genre": "æœªçŸ¥ç±»å‹",
                        "intro": "æš‚æ— ç®€ä»‹",
                        "words": 0,
                        "score": "0.0",
                        "status": "æœªçŸ¥",
                        "totalChapters": 1,
                        "tags": [],
                        "coverColor": "#eef7f2"
                    }
                });
            }

            // æ–°å¢ï¼šå†…å®¹æ¸…æ´—ä¸é€‚é…å™¨æ ¸å¿ƒé€»è¾‘
            cleanContent(content) {
                if (!content) return "";
                let text = String(content);

                // 1. å°è¯•å»é™¤ Markdown ä»£ç å—åŒ…è£¹
                if (text.trim().startsWith('```')) {
                    text = text.replace(/^```(json)?\s*/i, '').replace(/```\s*$/, '');
                }

                // 2. å°è¯•è§£æä¸º JSON å¯¹è±¡ (é’ˆå¯¹åµŒå¥— JSON å­—ç¬¦ä¸²çš„æƒ…å†µ)
                // æƒ…å†µ A: å®Œæ•´çš„ JSON å¯¹è±¡å­—ç¬¦ä¸² "{...}"
                if (text.trim().startsWith('{')) {
                    try {
                        const obj = JSON.parse(text);
                        // å¦‚æœè§£æå‡ºçš„å¯¹è±¡åŒ…å« content å­—æ®µï¼Œé€’å½’æ¸…æ´—è¯¥å­—æ®µ
                        if (obj.content) return this.cleanContent(obj.content);
                        // å¦‚æœåŒ…å« title å’Œ contentï¼Œå¯èƒ½å°±æ˜¯ç« èŠ‚å¯¹è±¡
                        if (obj.title && obj.content) return this.cleanContent(obj.content);
                    } catch (e) {
                        // è§£æå¤±è´¥ï¼Œè¯´æ˜ä¸æ˜¯åˆæ³•çš„ JSON å¯¹è±¡ï¼Œç»§ç»­åç»­å¤„ç†
                    }
                }

                // æƒ…å†µ B: æ ¼å¼é”™è¯¯æˆ–æˆªæ–­çš„ JSON ç‰‡æ®µ (é’ˆå¯¹ "key": "value", "content": "..." è¿™ç§)
                // å°è¯•æ­£åˆ™æå– "content": "..."
                // å¢å¼ºæ­£åˆ™ï¼šæ”¯æŒè·¨è¡Œï¼Œæ”¯æŒè½¬ä¹‰å¼•å·
                const contentMatch = text.match(/"content"\s*:\s*"((?:[^"\\]|\\.)*)"/s);
                if (contentMatch) {
                    try {
                        // ä½¿ç”¨ JSON.parse å¤„ç†è½¬ä¹‰å­—ç¬¦
                        return this.cleanContent(JSON.parse(`"${contentMatch[1]}"`));
                    } catch (e) {
                        // æå–å¤±è´¥ï¼Œå¿½ç•¥
                    }
                }
                
                // æƒ…å†µ C: é’ˆå¯¹ç”¨æˆ·æä¾›çš„ç‰¹æ®Šé”™è¯¯æ ¼å¼ (å¦‚ "ç¬¬ä¸€ç« ...", "content": "...")
                // è¿™ç§æ ¼å¼é€šå¸¸æ˜¯ JSON ç»“æ„é”™ä¹±ï¼Œå°è¯•ç›´æ¥åŒ¹é… content åçš„å†…å®¹
                if (text.includes('"content":')) {
                     const splitParts = text.split('"content":');
                     if (splitParts.length > 1) {
                         let potentialContent = splitParts[1].trim();
                         // å¦‚æœä»¥å¼•å·å¼€å¤´ï¼Œå°è¯•æå–å¼•å·å†…çš„å†…å®¹
                         if (potentialContent.startsWith('"')) {
                             // å¯»æ‰¾ä¸‹ä¸€ä¸ªæœªè½¬ä¹‰çš„å¼•å·
                             let endIdx = -1;
                             for (let i = 1; i < potentialContent.length; i++) {
                                 if (potentialContent[i] === '"' && potentialContent[i-1] !== '\\') {
                                     endIdx = i;
                                     break;
                                 }
                             }
                             if (endIdx !== -1) {
                                 try {
                                     return this.cleanContent(JSON.parse(potentialContent.substring(0, endIdx + 1)));
                                 } catch(e) {}
                             }
                         }
                     }
                }

                // 3. ç§»é™¤ä¹±ç å’Œæ§åˆ¶å­—ç¬¦
                // ç§»é™¤ ASCII æ§åˆ¶å­—ç¬¦ (0-31, 127)ï¼Œä¿ç•™æ¢è¡Œç¬¦(\n, \r)å’Œåˆ¶è¡¨ç¬¦(\t)
                // \x00-\x08, \x0B-\x0C, \x0E-\x1F, \x7F
                // eslint-disable-next-line no-control-regex
                text = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');

                // 4. ç®€å•çš„ HTML æ ‡ç­¾æ¸…ç† (å¯é€‰ï¼Œå¦‚æœç”¨æˆ·å¸Œæœ›ä¿ç•™æ ¼å¼åˆ™ä¸æ¸…ç†)
                // ç”¨æˆ·æ–‡ä»¶åŒ…å« <div style="...">ï¼Œè¯´æ˜éœ€è¦ä¿ç•™ HTML æ¸²æŸ“ã€‚
                // ä½†å¦‚æœ HTML æ ‡ç­¾è¢«è½¬ä¹‰äº† (å¦‚ <div>)ï¼Œå¯èƒ½éœ€è¦åè½¬ä¹‰ã€‚
                if (text.includes('<') && text.includes('>')) {
                    text = text.replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/&/g, '&');
                }
                
                // 5. å¤„ç†è½¬ä¹‰çš„æ¢è¡Œç¬¦
                text = text.replace(/\\n/g, '\n').replace(/\\r/g, '');

                return text;
            }

            parse(content, fileName) {
                if (fileName.endsWith('.json')) {
                    let jsonContent;
                    try {
                        jsonContent = JSON.parse(content);
                    } catch (e) {
                        return { success: false, message: "JSON è¯­æ³•é”™è¯¯", details: [e.message] };
                    }

                    // æ£€æŸ¥æ˜¯å¦ä¸ºç‰¹å®šæ ¼å¼ (åŒ…å« summary å’Œ chapters)
                    if (jsonContent.summary && Array.isArray(jsonContent.chapters)) {
                        return this.parseFullBookJson(jsonContent);
                    }

                    return this.jsonAdapter.parse(jsonContent);
                } else if (fileName.endsWith('.txt')) {
                    return this.parseTxt(content, fileName);
                } else {
                    return { success: false, message: "ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼" };
                }
            }

            parseFullBookJson(data) {
                const summary = data.summary;
                const chapters = data.chapters;

                // æ„é€ ä¹¦ç±å¯¹è±¡
                const book = {
                    id: summary.id || Date.now(),
                    title: summary.title || "æœªçŸ¥ä¹¦å",
                    author: summary.pairing || summary.author || "ä½šå", 
                    genre: "å¯¼å…¥ä¹¦ç±", 
                    intro: summary.summary || "",
                    tags: summary.tags || [],
                    words: 0, 
                    score: summary.rating || "0.0", 
                    status: (summary.stats && summary.stats.ending) ? "å·²å®Œç»“" : "è¿è½½ä¸­",
                    totalChapters: chapters.length,
                    coverColor: '#eef7f2'
                };

                // è®¡ç®—å­—æ•°
                let totalWords = 0;
                chapters.forEach(c => totalWords += (c.wordCount || 0));
                book.words = totalWords;

                // æå–ç« èŠ‚æ•°æ®
                const chapterData = {};
                const titleData = {};
                const authorSayData = {};
                const commentData = {};

                chapters.forEach(c => {
                    const idx = c.index;
                    // ä½¿ç”¨ cleanContent å¤„ç†ç« èŠ‚å†…å®¹
                    chapterData[idx] = this.cleanContent(c.content);
                    
                    titleData[idx] = c.title;
                    if (c.authorNote) authorSayData[idx] = c.authorNote;
                    if (c.comments && Array.isArray(c.comments)) {
                        commentData[idx] = c.comments.map(cm => ({
                            user: cm.author,
                            text: cm.content,
                            likes: 0 
                        }));
                    }
                });

                return {
                    success: true,
                    data: [book], 
                    isFullBook: true, 
                    extraData: {
                        bookId: book.id,
                        chapters: chapterData,
                        titles: titleData,
                        authorSays: authorSayData,
                        comments: commentData
                    },
                    message: `æˆåŠŸè§£æä¹¦ç±ã€Š${book.title}ã€‹åŠ ${chapters.length} ä¸ªç« èŠ‚`
                };
            }

            parseTxt(content, fileName) {
                let newBooks = [];
                try {
                    if (content.includes('=== ')) {
                        const parts = content.split('=== ').filter(p => p.trim());
                        parts.forEach(part => {
                            const lines = part.split('\n');
                            const titleLine = lines[0].trim();
                            const title = titleLine.replace(' ===', '');
                            
                            let author = "æœªçŸ¥";
                            let genre = "æœªçŸ¥";
                            let intro = "";
                            
                            lines.slice(1).forEach(line => {
                                if(line.startsWith('ä½œè€…ï¼š')) author = line.replace('ä½œè€…ï¼š', '').trim();
                                else if(line.startsWith('ç±»å‹ï¼š')) genre = line.replace('ç±»å‹ï¼š', '').trim();
                                else if(line.startsWith('ç®€ä»‹ï¼š')) intro = line.replace('ç®€ä»‹ï¼š', '').trim();
                                else if(line.trim()) intro += '\n' + line.trim();
                            });
                            
                            if(title) {
                                newBooks.push({
                                    id: Date.now() + Math.random(),
                                    title, author, genre, intro,
                                    tags: [],
                                    words: 0,
                                    score: "0.0",
                                    status: "æœªçŸ¥",
                                    totalChapters: 0,
                                    coverColor: '#eee'
                                });
                            }
                        });
                    } else {
                        const title = fileName.replace('.txt', '');
                        newBooks.push({
                            id: Date.now(),
                            title: title,
                            author: "æœ¬åœ°å¯¼å…¥",
                            genre: "æ–‡æœ¬æ–‡ä»¶",
                            intro: content.substring(0, 500) + (content.length > 500 ? "..." : ""),
                            tags: ["å¯¼å…¥"],
                            words: content.length,
                            score: "0.0",
                            status: "æœ¬åœ°",
                            totalChapters: 1,
                            coverColor: '#eef7f2'
                        });
                    }
                    return { success: true, data: newBooks, message: `æˆåŠŸè§£æ ${newBooks.length} æœ¬TXTä¹¦ç±`, logs: ["TXTè§£æå®Œæˆ"] };
                } catch (e) {
                    return { success: false, message: "TXTè§£æé”™è¯¯", details: [e.message] };
                }
            }
        }

        // æ•°å­—è½¬ä¸­æ–‡å·¥å…·å‡½æ•°
        function toChineseNum(num) {
            const chnNumChar = ["é›¶", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹"];
            const chnUnitSection = ["", "ä¸‡", "äº¿", "ä¸‡äº¿", "äº¿äº¿"];
            const chnUnitChar = ["", "å", "ç™¾", "åƒ"];
            const sectionToChinese = (section) => {
                let strIns = '', chnStr = '';
                let unitPos = 0;
                let zero = true;
                while (section > 0) {
                    let v = section % 10;
                    if (v === 0) {
                        if (!zero) {
                            zero = true;
                            chnStr = chnNumChar[v] + chnStr;
                        }
                    } else {
                        zero = false;
                        strIns = chnNumChar[v];
                        strIns += chnUnitChar[unitPos];
                        chnStr = strIns + chnStr;
                    }
                    unitPos++;
                    section = Math.floor(section / 10);
                }
                return chnStr;
            }
            let unitPos = 0;
            let strIns = '', chnStr = '';
            let needZero = false;
            if (num === 0) return chnNumChar[0];
            while (num > 0) {
                let section = num % 10000;
                if (needZero) chnStr = chnNumChar[0] + chnStr;
                strIns = sectionToChinese(section);
                strIns += (section !== 0) ? chnUnitSection[unitPos] : chnUnitSection[0];
                chnStr = strIns + chnStr;
                needZero = (section < 1000) && (section > 0);
                num = Math.floor(num / 10000);
                unitPos++;
            }
            if (chnStr.startsWith('ä¸€å')) chnStr = chnStr.substring(1);
            return chnStr;
        }

        // å®‰å…¨åŠ è½½ä¹¦æ¶æ•°æ®
        let initialBookshelf = [];
        try {
            initialBookshelf = JSON.parse(localStorage.getItem('jj_bookshelf')) || [];
        } catch (e) {
            console.error("ä¹¦æ¶æ•°æ®åŠ è½½å¤±è´¥ï¼Œé‡ç½®ä¸ºç©º", e);
            initialBookshelf = [];
        }

        // --- æ ¸å¿ƒé¢„è®¾æ•°æ®è¿ç§»é€»è¾‘ ---
        let storedPresets = [];
        try {
            storedPresets = JSON.parse(localStorage.getItem('jj_core_presets')) || [];
            // æ£€æŸ¥æ˜¯å¦ä¸ºæ—§ç‰ˆæ•°æ® (æ—  id å­—æ®µ)
            if (storedPresets.length > 0 && !storedPresets[0].id) {
                console.log("æ£€æµ‹åˆ°æ—§ç‰ˆé¢„è®¾æ•°æ®ï¼Œæ­£åœ¨è¿ç§»...");
                const currentName = localStorage.getItem('jj_current_preset_name');
                storedPresets = storedPresets.map((p, idx) => ({
                    id: Date.now() + idx,
                    name: p.name,
                    content: p.content,
                    isActive: (p.name === currentName), // å°è¯•ä¿ç•™æ¿€æ´»çŠ¶æ€
                    isExpanded: false,
                    regexRules: []
                }));
                localStorage.setItem('jj_core_presets', JSON.stringify(storedPresets));
            }
        } catch (e) {
            console.error("é¢„è®¾æ•°æ®åŠ è½½å¤±è´¥", e);
            storedPresets = [];
        }

        const state = {
            currentBook: null,
            currentChapter: 1, // å½“å‰æ­£åœ¨é˜…è¯»çš„ç« èŠ‚å·
            bookshelf: initialBookshelf,
            worldSettings: JSON.parse(localStorage.getItem('jj_world')) || [],
            // æ–°å¢ï¼šç« èŠ‚å†…å®¹ç¼“å­˜ { bookId: { 1: "content...", 2: "content..." } }
            chapterCache: JSON.parse(localStorage.getItem('jj_chapter_cache')) || {},
            // æ–°å¢ï¼šç« èŠ‚æ ‡é¢˜ç¼“å­˜ { bookId: { 1: "Title", 2: "Title" } }
            chapterTitles: JSON.parse(localStorage.getItem('jj_chapter_titles')) || {},
            // æ–°å¢ï¼šç« èŠ‚æ‘˜è¦ç¼“å­˜
            chapterSummaries: JSON.parse(localStorage.getItem('jj_chapter_summaries')) || {},
            // æ–°å¢ï¼šåºŸå¼ƒç« èŠ‚ { bookId: { chapterNum: [ {content, authorSay, title, timestamp} ] } }
            abandonedChapters: JSON.parse(localStorage.getItem('jj_abandoned_chapters')) || {},
            // æ–°å¢ï¼šä½œè€…åè¯ç¼“å­˜ { bookId: { chapterNum: "..." } }
            authorSays: JSON.parse(localStorage.getItem('jj_author_says')) || {},
            // æ–°å¢ï¼šè¯„è®ºç¼“å­˜ { bookId: { chapterNum: [ {user, text, likes} ] } }
            comments: JSON.parse(localStorage.getItem('jj_comments')) || {},
            
            // æ–°å¢ï¼šä¹¦ç±è®¾ç½® { bookId: { minWords: 2000 } }
            bookSettings: JSON.parse(localStorage.getItem('jj_book_settings')) || {},
            readingProgress: JSON.parse(localStorage.getItem('jj_reading_progress')) || {},
            homeFilter: 'mix', // mix, short, long

            config: JSON.parse(localStorage.getItem('jj_config')) || {
                apiKey: '',
                model: 'gemini-1.5-flash',
                apiUrl: '',
                apiType: 'gemini'
            },
            configList: JSON.parse(localStorage.getItem('jj_config_list')) || [],
            // æ ¸å¿ƒæŒ‡ä»¤
            corePresets: storedPresets, // ä½¿ç”¨è¿ç§»åçš„æ•°æ®
            currentCoreInstruction: localStorage.getItem('jj_current_core_instruction') || "",
            currentPresetName: localStorage.getItem('jj_current_preset_name') || "",
            
            // å¤–è§‚è®¾ç½®
            appearance: JSON.parse(localStorage.getItem('jj_appearance')) || {
                bgImage: null, // Base64 string
                bgBlur: 0,
                bgMask: 0,
                isDark: false,
                font: 'default',
                fontSize: 16,
                customFonts: [], // { name, data }
                themes: [], // { name, config }
                customCSS: ""
            },

            generatedPages: [],
            currentPageIndex: 0,
            lastPrompt: "",
            selectedBooks: new Set(),
            isBatchMode: false,
            detailSource: 'home',
            
            // é¦–é¡µæœç´¢æ ‡ç­¾
            selectedSearchTags: [], // {name, id}
            
            // ä¸–ç•Œè§‚æ‰¹é‡æ“ä½œ
            worldBatchMode: {
                character: false,
                func_worldbook: false,
                worldbook: false
            },
            selectedWorldItems: {
                character: new Set(),
                func_worldbook: new Set(),
                worldbook: new Set()
            }
        };

        // åˆå§‹åŒ–é»˜è®¤æ ‡ç­¾åº“
        function initDefaultTags() {
            const initKey = 'jj_default_tags_initialized_v2';
            if (!localStorage.getItem(initKey)) {
                const defaultTags = [
                    "ABO", "å“¨å‘", "å¼ºå¼º", "ç”Ÿå­", "ç ´é•œé‡åœ†", "è¿½å¦»ç«è‘¬åœº", "å¨±ä¹åœˆ", "æ— é™æµ", "ç³»ç»Ÿ", "å¿«ç©¿", 
                    "ç©¿ä¹¦", "ç§ç”°", "ç¾é£Ÿ", "æ˜Ÿé™…", "æœºç”²", "èµ›åšæœ‹å…‹", "å…‹è‹é²", "çµå¼‚ç¥æ€ª", "ä»™ä¾ ä¿®çœŸ", "è¥¿å¹»", 
                    "å®«å»·ä¾¯çˆµ", "è±ªé—¨ä¸–å®¶", "æ ¡å›­", "é’æ¢…ç«¹é©¬", "æ‚¬ç–‘æ¨ç†", "ææ€–", "æƒŠæ‚š", "çˆ½æ–‡", "ç”œå® ", "è™æ–‡", 
                    "HE", "BE", "OE", "äº’æ”»", "å¹´ä¸‹", "å¹´ä¸Š", "å¸ˆå¾’", "æ›¿èº«", "ç™½æœˆå…‰", "æœ±ç ‚ç—£", 
                    "ä¼ªéª¨ç§‘", "å¼ºåˆ¶çˆ±", "ç›¸çˆ±ç›¸æ€", "æœ«ä¸–", "åŸºå»º", "ç¾¤åƒ", "é©¬ç”²æ–‡", "ç›´æ’­", "ç”µç«", "å’¸é±¼ç¿»èº«"
                ];
                
                let addedCount = 0;
                defaultTags.forEach(tagName => {
                    if (!state.worldSettings.some(w => w.type === 'tag' && w.name === tagName)) {
                        state.worldSettings.push({
                            id: Date.now() + Math.random(),
                            type: 'tag',
                            name: tagName,
                            desc: 'ç³»ç»Ÿé¢„ç½®çƒ­é—¨æ ‡ç­¾'
                        });
                        addedCount++;
                    }
                });
                
                if (addedCount > 0) saveWorldData();
                localStorage.setItem(initKey, 'true');
            }
        }
        // æ‰§è¡Œåˆå§‹åŒ–
        initDefaultTags();

        // ä¿®æ”¹ï¼šç»Ÿä¸€å…¨å±€æ ‡ç­¾åº“åŒæ­¥é€»è¾‘ (ä»…è§’è‰²ã€ä¸–ç•Œä¹¦ -> æ ‡ç­¾)
        // ä¹¦ç±æ ‡ç­¾åŒæ­¥ç°åœ¨ç”± syncTagsFromNewBooks åœ¨ç”Ÿæˆæ—¶å•ç‹¬å¤„ç†
        function syncGlobalTags() {
            let hasNew = false;
            // è·å–å½“å‰æ‰€æœ‰æ ‡ç­¾åç§°æ˜ å°„ï¼Œæ–¹ä¾¿æŸ¥æ‰¾å’Œæ›´æ–°
            const tagMap = new Map();
            state.worldSettings.forEach(w => {
                if (w.type === 'tag') tagMap.set(w.name, w);
            });
            
            const newTags = [];

            // 2. åŒæ­¥è§’è‰²å’Œä¸–ç•Œä¹¦
            state.worldSettings.forEach(item => {
                if (item.type === 'character' || item.type === 'worldbook') {
                    if (tagMap.has(item.name)) {
                        // è§„åˆ™1ï¼šè®¾å®šç‰¹å®šæ ‡ç­¾çš„ç½®é¡¶è§„åˆ™
                        // å¦‚æœæ ‡ç­¾å·²å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦å‡çº§ä¸ºç½®é¡¶ï¼ˆå¯¹åº”è§’è‰²æˆ–ä¸–ç•Œä¹¦çš„æ ‡ç­¾é¡»å§‹ç»ˆç½®é¡¶ï¼‰
                        const existingTag = tagMap.get(item.name);
                        if (!existingTag.isPinned) {
                            existingTag.isPinned = true;
                            // æ›´æ–°æè¿°ï¼Œæ ‡è®°æ¥æº
                            if (!existingTag.desc.includes('åŒæ­¥')) {
                                existingTag.desc = (item.type === 'character' ? 'æ¥æºï¼šè§’è‰²è®¾å®šåŒæ­¥' : 'æ¥æºï¼šæ ‡ç­¾ä¸–ç•Œä¹¦åŒæ­¥') + ' (å·²ç½®é¡¶)';
                            }
                            hasNew = true;
                        }
                    } else {
                        // æ–°å¢æ ‡ç­¾ï¼Œç›´æ¥èµ‹äºˆç½®é¡¶å±æ€§
                        newTags.push({
                            id: Date.now() + Math.random(),
                            type: 'tag',
                            name: item.name,
                            desc: item.type === 'character' ? 'æ¥æºï¼šè§’è‰²è®¾å®šåŒæ­¥' : 'æ¥æºï¼šæ ‡ç­¾ä¸–ç•Œä¹¦åŒæ­¥',
                            isPinned: true // è®¾å®šç½®é¡¶å±æ€§
                        });
                        // é˜²æ­¢é‡å¤æ·»åŠ åŒåæ ‡ç­¾
                        tagMap.set(item.name, { isPinned: true }); 
                        hasNew = true;
                    }
                }
            });

            if (hasNew) {
                state.worldSettings.push(...newTags);
                saveWorldData();
                console.log("å·²è‡ªåŠ¨åŒæ­¥å…¨å±€æ ‡ç­¾åº“ï¼ˆå«ç½®é¡¶æ›´æ–°ï¼‰");
                // å¦‚æœå½“å‰åœ¨æ ‡ç­¾é¡µï¼Œåˆ·æ–°åˆ—è¡¨
                const tagTab = document.getElementById('tab_content_tag');
                if(tagTab && tagTab.style.display === 'block') {
                    renderSection('tag');
                }
            }
        }

        // æ–°å¢ï¼šä»…åœ¨ç”Ÿæˆæ–°ä¹¦æ—¶è°ƒç”¨ï¼Œå°†æ–°æ ‡ç­¾å½•å…¥å…¨å±€åº“
        function syncTagsFromNewBooks(books) {
            if (!books || books.length === 0) return;
            
            let hasNew = false;
            const existingTags = new Set(state.worldSettings.filter(w => w.type === 'tag').map(w => w.name));
            const newTags = [];

            books.forEach(book => {
                if (book.tags && Array.isArray(book.tags)) {
                    book.tags.forEach(tagName => {
                        if (tagName && !existingTags.has(tagName)) {
                            newTags.push({
                                id: Date.now() + Math.random(),
                                type: 'tag',
                                name: tagName,
                                desc: 'æ¥æºï¼šæ–°ä¹¦ç”Ÿæˆè‡ªåŠ¨å½•å…¥'
                            });
                            existingTags.add(tagName);
                            hasNew = true;
                        }
                    });
                }
            });

            if (hasNew) {
                state.worldSettings.push(...newTags);
                saveWorldData();
                console.log("å·²è‡ªåŠ¨å½•å…¥æ–°ä¹¦æ ‡ç­¾åˆ°å…¨å±€åº“");
                // å¦‚æœå½“å‰åœ¨æ ‡ç­¾é¡µï¼Œåˆ·æ–°åˆ—è¡¨
                const tagTab = document.getElementById('tab_content_tag');
                if(tagTab && tagTab.style.display === 'block') {
                    renderSection('tag');
                }
            }
        }

        // åˆå§‹åŒ–æ—¶åŒæ­¥ä¸€æ¬¡ (ç¡®ä¿ç½®é¡¶è§„åˆ™ç”Ÿæ•ˆ)
        syncGlobalTags();

        // è¾…åŠ©å‡½æ•°ï¼šè·å–å¸¦æ ¸å¿ƒæŒ‡ä»¤çš„ Prompt (é‡æ„ï¼šæ”¯æŒå¤šé¢„è®¾å åŠ )
        function getFullPrompt(userPrompt) {
            // 1. å…¨å±€æŒ‡ä»¤
            let finalPrompt = state.currentCoreInstruction ? `ã€å…¨å±€æ ¸å¿ƒæŒ‡ä»¤ã€‘ï¼š\n${state.currentCoreInstruction}\n\n` : "";
            
            // 2. æ¿€æ´»çš„é¢„è®¾æŒ‡ä»¤
            // é€»è¾‘ä¿®æ­£ï¼šé¢„è®¾æ€»å¼€å…³ä¸ºæœ€é«˜æ§åˆ¶çº§ï¼›ä»…å½“é¢„è®¾å¼€å¯æ—¶ï¼Œå…¶å†…éƒ¨å¼€å¯çš„æ¡ç›®æ‰ç”Ÿæ•ˆã€‚
            // å®æ—¶æ„å»ºå†…å®¹ï¼Œç¡®ä¿ä¸ä¾èµ–ç¼“å­˜ï¼Œä¸¥æ ¼éµå¾ªå¼€å…³å±‚çº§ã€‚
            const activePresets = state.corePresets.filter(p => p.isActive);
            
            if (activePresets.length > 0) {
                finalPrompt += "ã€é™„åŠ æŒ‡ä»¤é›†ã€‘ï¼š\n";
                activePresets.forEach(p => {
                    // ç¡®ä¿ entries æ•°æ®å­˜åœ¨
                    if (!p.entries || p.entries.length === 0) {
                        p.entries = parseContentToEntries(p.content || "");
                    }
                    
                    // åŠ¨æ€æ„å»ºå†…å®¹ï¼šåªè¯»å–è¯¥é¢„è®¾å†…â€œå­å¼€å…³â€ä¸ºå¼€å¯çŠ¶æ€çš„æ¡ç›®
                    const validContent = rebuildPresetContent(p.entries);
                    
                    if (validContent && validContent.trim()) {
                        finalPrompt += `[${p.name}]: ${validContent}\n`;
                    }
                });
                finalPrompt += "\n";
            }
            
            finalPrompt += "----------------\n" + userPrompt;
            return finalPrompt;
        }

        // æ–°å¢ï¼šåº”ç”¨æ¿€æ´»çš„æ­£åˆ™è§„åˆ™ (åå¤„ç†)
        function applyActiveRegexRules(text) {
            if (!text) return text;
            let processedText = text;
            
            // éå†æ‰€æœ‰æ¿€æ´»çš„é¢„è®¾
            state.corePresets.filter(p => p.isActive).forEach(preset => {
                if (preset.regexRules && preset.regexRules.length > 0) {
                    // éå†è¯¥é¢„è®¾ä¸‹æ‰€æœ‰æ¿€æ´»çš„è§„åˆ™
                    preset.regexRules.filter(r => r.isActive).forEach(rule => {
                        try {
                            let pattern = rule.pattern;
                            let flags = 'g';

                            // æ™ºèƒ½è¯†åˆ« /pattern/flags æ ¼å¼
                            if (pattern.startsWith('/') && pattern.lastIndexOf('/') > 0) {
                                const lastSlashIndex = pattern.lastIndexOf('/');
                                const potentialFlags = pattern.substring(lastSlashIndex + 1);
                                // æ£€æŸ¥åç¼€æ˜¯å¦åªåŒ…å«åˆæ³•çš„æ­£åˆ™æ ‡å¿—ä½
                                if (/^[gimsuy]*$/.test(potentialFlags)) {
                                    pattern = pattern.substring(1, lastSlashIndex);
                                    flags = potentialFlags;
                                    if (!flags.includes('g')) flags += 'g'; // å¼ºåˆ¶å…¨å±€æ›¿æ¢
                                }
                            }

                            const regex = new RegExp(pattern, flags);
                            // å¤„ç† replacement ä¸­çš„è½¬ä¹‰å­—ç¬¦ï¼Œå¦‚ \n
                            const replacement = (rule.replacement || "").replace(/\\n/g, '\n').replace(/\\t/g, '\t');
                            processedText = processedText.replace(regex, replacement);
                        } catch (e) {
                            console.warn(`æ­£åˆ™è§„åˆ™æ‰§è¡Œå¤±è´¥ [${preset.name}-${rule.name}]:`, e);
                        }
                    });
                }
            });
            
            return processedText;
        }

        // è¾…åŠ©å‡½æ•°ï¼šä»æ–‡æœ¬ä¸­æå–ä¸–ç•Œè§‚è®¾å®š
        function getWorldContext(text) {
            if (!text) return "";
            let context = [];
            
            // 1. å¸¸è§„åŒ¹é… (æ’é™¤åŠŸèƒ½ä¸–ç•Œä¹¦å’Œæ ‡ç­¾ä¸–ç•Œä¹¦ï¼Œå®ƒä»¬é€šè¿‡å…³è”è§¦å‘æˆ–ç›´æ¥æåŠè§¦å‘)
            // ä¿®æ”¹ï¼šæ ‡ç­¾ä¸–ç•Œä¹¦ç°åœ¨ä¹Ÿæ”¯æŒå…³è”ï¼Œæ‰€ä»¥é€»è¾‘éœ€è¦è°ƒæ•´
            // ç­–ç•¥ï¼š
            // - è§’è‰²ï¼šç›´æ¥æåŠè§¦å‘
            // - æ ‡ç­¾ï¼šç›´æ¥æåŠè§¦å‘
            // - åŠŸèƒ½ä¸–ç•Œä¹¦ï¼šå…³è”çš„è§’è‰²è¢«æåŠè§¦å‘
            // - æ ‡ç­¾ä¸–ç•Œä¹¦ï¼šç›´æ¥æåŠè§¦å‘ OR å…³è”çš„è§’è‰²è¢«æåŠè§¦å‘
            
            const mentionedCharacters = state.worldSettings.filter(item => item.type === 'character' && text.includes(item.name));
            
            state.worldSettings.forEach(item => {
                // è§’è‰²å’Œæ ‡ç­¾ï¼šç›´æ¥åŒ¹é…
                if ((item.type === 'character' || item.type === 'tag') && text.includes(item.name)) {
                    context.push(`ã€${item.type === 'character' ? 'è§’è‰²' : 'æ ‡ç­¾'} - ${item.name}ã€‘ï¼š${item.desc}`);
                }
                
                // æ ‡ç­¾ä¸–ç•Œä¹¦ï¼šç›´æ¥åŒ¹é…
                if (item.type === 'worldbook' && text.includes(item.name)) {
                    context.push(`ã€æ ‡ç­¾ä¸–ç•Œä¹¦ - ${item.name}ã€‘ï¼š${item.desc}`);
                }
            });

            // 2. å…³è”è§¦å‘ (åŠŸèƒ½ä¸–ç•Œä¹¦ & æ ‡ç­¾ä¸–ç•Œä¹¦)
            const complexBooks = state.worldSettings.filter(item => item.type === 'func_worldbook' || item.type === 'worldbook');
            
            complexBooks.forEach(book => {
                // å¦‚æœè¯¥ä¹¦å…³è”çš„è§’è‰²è¢«æåŠ
                if (book.relatedIds && book.relatedIds.some(id => mentionedCharacters.some(c => c.id === id))) {
                     const typeName = book.type === 'func_worldbook' ? 'åŠŸèƒ½è®¾å®š' : 'æ ‡ç­¾ä¸–ç•Œä¹¦';
                     context.push(`ã€${typeName} - ${book.name}ã€‘ï¼š${book.desc}`);
                }
            });

            return [...new Set(context)].join('\n');
        }

        // --- API è°ƒç”¨æ ¸å¿ƒå‡½æ•° ---
        async function callGeminiAPI(prompt, options = {}) {
            const apiKey = state.config.apiKey;
            if (!apiKey) throw new Error("æœªé…ç½® API Key");

            const model = state.config.model || 'gemini-1.5-flash';
            let baseUrl = state.config.apiUrl || 'https://generativelanguage.googleapis.com';
            const apiType = state.config.apiType || 'gemini';

            // å¤„ç† baseUrl æ ¼å¼
            if(baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);

            // å…¼å®¹æ—§å‚æ•° isJsonMode (boolean)
            const isJsonMode = typeof options === 'boolean' ? options : (options.jsonMode || false);
            const generationConfig = (typeof options === 'object' && options.generationConfig) ? options.generationConfig : {};

            // è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–é”™è¯¯ä¿¡æ¯
            const formatError = (status, errText) => {
                let detail = errText;
                try {
                    // å°è¯•è§£æ JSON é”™è¯¯
                    const errObj = JSON.parse(errText);
                    detail = JSON.stringify(errObj); // ä¿æŒç´§å‡‘çš„ JSON å­—ç¬¦ä¸²
                } catch (e) {
                    // ä¿æŒåŸæ ·
                }
                return `ç”Ÿæˆå¤±è´¥ï¼šAPI Error ${status} - ${detail}`;
            };

            // --- åˆ†æ”¯ 1: Google Gemini ---
            if (apiType === 'gemini') {
                let url = baseUrl;
                // æ™ºèƒ½æ„å»º URL
                if (!url.includes(':generateContent')) {
                    if (!url.includes('/models')) {
                        if (!url.includes('/v1beta') && !url.includes('/v1')) {
                            url += '/v1beta';
                        }
                        url += '/models';
                    }
                    url += `/${model}:generateContent`;
                }

                const separator = url.includes('?') ? '&' : '?';
                const finalUrl = `${url}${separator}key=${apiKey}`;
                
                const payload = {
                    contents: [{
                        parts: [{ text: prompt }]
                    }],
                    generationConfig: generationConfig
                };

                if (isJsonMode) {
                    payload.generationConfig.response_mime_type = "application/json";
                }

                try {
                    const response = await fetch(finalUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(formatError(response.status, errText));
                    }

                    const data = await response.json();
                    if (!data.candidates || !data.candidates[0].content) {
                        throw new Error("API è¿”å›æ ¼å¼å¼‚å¸¸: ç¼ºå°‘ candidates æˆ– content");
                    }
                    
                    return data.candidates[0].content.parts[0].text;
                } catch (error) {
                    console.error("Gemini API Call Failed:", error);
                    throw error;
                }
            } 
            // --- åˆ†æ”¯ 2: OpenAI / è‡ªå®šä¹‰å…¼å®¹ ---
            else {
                let url = baseUrl;
                // æ™ºèƒ½æ„å»º URL: ç¡®ä¿ä»¥ /v1/chat/completions ç»“å°¾
                if (!url.includes('/chat/completions')) {
                    if (!url.includes('/v1')) {
                        url += '/v1';
                    }
                    url += '/chat/completions';
                }

                // ç®€å•çš„ Prompt æ‹†åˆ† (å°è¯•åˆ†ç¦» System Prompt)
                let messages = [];
                const sysPromptMatch = prompt.match(/\[System Prompt\]([\s\S]*?)(\[User|User Keywords|$)/i);
                
                if (sysPromptMatch) {
                    const sysContent = sysPromptMatch[1].trim();
                    // ç§»é™¤ System Prompt éƒ¨åˆ†ï¼Œå‰©ä¸‹çš„ä½œä¸º User Prompt
                    let userContent = prompt.replace(sysPromptMatch[0], '').trim();
                    // å¦‚æœå¼€å¤´è¿˜æœ‰ User Keywords æ ‡è®°ï¼Œä¹Ÿæ¸…ç†ä¸€ä¸‹
                    userContent = userContent.replace(/^User Keywords:\s*/i, '').trim();
                    // å¦‚æœ userContent ä¸ºç©ºï¼ˆåªæœ‰ system promptï¼‰ï¼Œåˆ™å…¨æ”¾ system æˆ–è¡¥ä¸€ä¸ªç©º user
                    if(!userContent) userContent = "Start generation.";

                    messages.push({ role: "system", content: sysContent });
                    messages.push({ role: "user", content: userContent });
                } else {
                    messages.push({ role: "user", content: prompt });
                }

                const payload = {
                    model: model,
                    messages: messages,
                    temperature: 0.7
                };

                if (isJsonMode) {
                    payload.response_format = { type: "json_object" };
                }
                
                // æ˜ å°„ maxOutputTokens -> max_tokens
                if (generationConfig.maxOutputTokens) {
                    payload.max_tokens = generationConfig.maxOutputTokens;
                }

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(formatError(response.status, errText));
                    }

                    const data = await response.json();
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error("API è¿”å›æ ¼å¼å¼‚å¸¸ (OpenAI Compatible): ç¼ºå°‘ choices æˆ– message");
                    }
                    
                    return data.choices[0].message.content;
                } catch (error) {
                    console.error("OpenAI API Call Failed:", error);
                    throw error;
                }
            }
        }

        function navTo(pageId) {
            document.querySelectorAll('.page').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            
            const navIndex = ['home', 'bookshelf', 'world', 'settings'].indexOf(pageId);
            if(navIndex !== -1) {
                document.querySelectorAll('.nav-item')[navIndex].classList.add('active');
            }
            
            if (pageId === 'reader') {
                document.getElementById('mainNav').style.display = 'none'; // é˜…è¯»æ¨¡å¼éšè—å¯¼èˆª
                document.body.style.paddingBottom = '0px';
            } else {
                document.getElementById('mainNav').style.display = 'flex';
                document.body.style.paddingBottom = '100px';
            }

            if (pageId === 'home') renderHomeTags();
            if (pageId === 'bookshelf') renderShelf();
            if (pageId === 'world') renderWorldPage();
            if (pageId === 'settings') loadSettingsUI();
            if (pageId === 'detail' && state.currentBook) {
                const btnRead = document.getElementById('btnStartRead');
                if (btnRead) {
                    const progress = state.readingProgress[state.currentBook.id];
                    if (progress) {
                        btnRead.innerText = `ç»§ç»­é˜…è¯» (ç¬¬${toChineseNum(progress)}ç« )`;
                        btnRead.setAttribute('onclick', `startReading(${progress})`);
                    } else {
                        btnRead.innerText = "å¼€å§‹é˜…è¯»";
                        btnRead.setAttribute('onclick', `startReading(1)`);
                    }
                }
            }
            
            // æ‚¬æµ®æŒ‰é’®æ§åˆ¶
            const floatMenu = document.getElementById('readerFloatMenu');
            if (pageId === 'reader') {
                if(floatMenu) floatMenu.style.display = 'flex';
            } else {
                if(floatMenu) floatMenu.style.display = 'none';
                // éšè—æ‰€æœ‰é¢æ¿å’Œé‡ç½®èœå•çŠ¶æ€
                document.querySelectorAll('.float-panel').forEach(el => el.classList.remove('active'));
                const subBtns = document.getElementById('floatSubBtns');
                const mainBtn = document.querySelector('.float-btn.main-btn');
                if(subBtns) subBtns.classList.remove('active');
                if(mainBtn) mainBtn.classList.remove('active');
            }
        }

        function toggleFloatMenu() {
            const subBtns = document.getElementById('floatSubBtns');
            const mainBtn = document.querySelector('.float-btn.main-btn');
            subBtns.classList.toggle('active');
            mainBtn.classList.toggle('active');
        }

        function toggleFloatPanel(type) {
            const panels = ['author', 'plot', 'comment', 'wordcount', 'summary'];
            const targetPanelId = 'panel' + type.charAt(0).toUpperCase() + type.slice(1);
            const targetPanel = document.getElementById(targetPanelId);
            
            // å…³é—­å…¶ä»–é¢æ¿
            panels.forEach(p => {
                if (p !== type) {
                    const pid = 'panel' + p.charAt(0).toUpperCase() + p.slice(1);
                    const el = document.getElementById(pid);
                    if (el) el.classList.remove('active');
                }
            });
            
            // åˆ‡æ¢å½“å‰é¢æ¿
            if (targetPanel) {
                targetPanel.classList.toggle('active');
            }
        }

        // é¦–é¡µæ ‡ç­¾äº¤äº’é€»è¾‘é‡æ„
        function addTag(text, el) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            if (state.selectedSearchTags.some(t => t.name === text)) return;
            
            state.selectedSearchTags.push({ name: text, id: Date.now() });
            renderSearchTags();
            
            // æ¸…ç©ºè¾“å…¥æ¡†çš„ç­›é€‰è¯ï¼Œä»¥ä¾¿ç»§ç»­æœç´¢
            document.getElementById('realSearchInput').value = '';
            filterHomeTags(); // æ¢å¤æ˜¾ç¤ºæ‰€æœ‰æ ‡ç­¾
        }

        function removeSearchTag(id) {
            state.selectedSearchTags = state.selectedSearchTags.filter(t => t.id !== id);
            renderSearchTags();
            filterHomeTags(); // åˆ·æ–°æ ‡ç­¾æ± çŠ¶æ€
        }

        function renderSearchTags() {
            const container = document.getElementById('selectedTagsContainer');
            container.innerHTML = state.selectedSearchTags.map(t => `
                <div class="search-tag-item">
                    <span>${t.name}</span>
                    <span class="search-tag-remove" onclick="removeSearchTag(${t.id})">Ã—</span>
                </div>
            `).join('');
        }

        function filterHomeTags() {
            const inputVal = document.getElementById('realSearchInput').value.toLowerCase();
            renderHomeTags(inputVal);
        }

        // è·å–å®Œæ•´çš„ Prompt (æ ‡ç­¾ + è¾“å…¥æ–‡æœ¬)
        function getCombinedPrompt() {
            const tags = state.selectedSearchTags.map(t => t.name).join(' ');
            const text = document.getElementById('realSearchInput').value;
            return (tags + ' ' + text).trim();
        }

        function setHomeFilter(mode) {
            state.homeFilter = mode;
            // æ›´æ–°æŒ‰é’®æ ·å¼
            ['mix', 'short', 'long'].forEach(m => {
                const btn = document.getElementById('filterBtn' + m.charAt(0).toUpperCase() + m.slice(1));
                if(m === mode) {
                    btn.classList.add('btn-jj');
                    btn.classList.remove('btn-outline');
                } else {
                    btn.classList.remove('btn-jj');
                    btn.classList.add('btn-outline');
                }
            });
            // é‡æ–°ç”Ÿæˆ
            if(document.getElementById('promptInput').value) {
                startNewGeneration();
            }
        }

        function renderHomeTags(filterText = "") {
            const cloud = document.getElementById('homeTagCloud');
            
            // æ”¶é›†æ‰€æœ‰æ ‡ç­¾
            let worldTags = state.worldSettings
                .filter(w => w.type === 'tag')
                .sort((a, b) => {
                    // ä¼˜å…ˆç½®é¡¶
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;
                    // ç„¶åæŒ‰æ—¶é—´å€’åº
                    return b.id - a.id;
                });
            
            // è¿‡æ»¤ï¼šæ’é™¤å·²é€‰ä¸­çš„ï¼Œä¸”åŒ¹é…è¾“å…¥æ–‡æœ¬
            const selectedNames = new Set(state.selectedSearchTags.map(t => t.name));
            worldTags = worldTags.filter(w => !selectedNames.has(w.name));
            
            if (filterText) {
                worldTags = worldTags.filter(w => w.name.toLowerCase().includes(filterText));
            }
            
            if (worldTags.length === 0) {
                cloud.innerHTML = '<div style="color:#999; font-size:12px; width:100%; text-align:center;">æš‚æ— åŒ¹é…æ ‡ç­¾</div>';
                return;
            }

            // ç»Ÿä¸€æ¸²æŸ“
            cloud.innerHTML = worldTags.map(w => 
                `<span class="tag-chip ${w.isPinned ? 'pinned' : ''}" onclick="addTag('${w.name}', this)">${w.name}</span>`
            ).join('');
        }

        function startNewGeneration() {
            state.generatedPages = [];
            state.currentPageIndex = 0;
            state.lastPrompt = getCombinedPrompt();
            generateBatch(true);
        }

        function generateNextPage() {
            if (state.currentPageIndex < state.generatedPages.length - 1) {
                changePage(1);
            } else {
                generateBatch(false);
            }
        }

        async function generateBatch(isFirstPage) {
            const prompt = state.lastPrompt;
            if(!prompt) return alert("è¯·è¾“å…¥ä¸€ç‚¹çµæ„Ÿå§ï¼");

            const resultsDiv = document.getElementById('generatedResults');
            const paginationControls = document.getElementById('paginationControls');
            
            if(isFirstPage) {
                resultsDiv.innerHTML = '<div style="text-align:center; padding:20px;">ä½œå®¶æ­£åœ¨ç«é€Ÿç¿»ç‚’... </div>';
                paginationControls.style.display = 'none';
            } else {
                document.getElementById('btnNext').innerText = "æ–°é²œç¾å‘³çš„é¥­ç«é€Ÿèµ¶æ¥...";
                document.getElementById('btnNext').disabled = true;
            }

            let books = [];
            if (state.config.apiKey) {
                 try {
                     // æ³¨å…¥ç­›é€‰è§„åˆ™
                     let lengthRule = "";
                     if (state.homeFilter === 'short') lengthRule = "4. Total chapters MUST be between 1 and 8.";
                     else if (state.homeFilter === 'long') lengthRule = "4. Total chapters MUST be between 8 and 25.";
                     else lengthRule = "4. For the first 2 stories, chapters 1-8; for the last 3, chapters 8-25.";

                     // æ³¨å…¥ä¸–ç•Œè§‚ä¸Šä¸‹æ–‡
                     const worldContext = getWorldContext(prompt);

                     const systemPrompt = `[System Prompt]
Task: Generate 5 distinct fanfiction or original story summaries based on user keywords.

CONTEXT DATA (Use if relevant):
${worldContext || "None"}

IMPORTANT: All output MUST BE IN SIMPLIFIED CHINESE (ç®€ä½“ä¸­æ–‡).

REQUIREMENTS:
1. Include realistic AO3-style statistics (hits, kudos, bookmarks).
2. Define 'totalChapters' (e.g., 5 to 30) for pacing.
3. Define 'ending' as HE (Happy), BE (Bad), or OE (Open).
${lengthRule}

Format strictly as JSON array:
[
  { 
    "title": "...", 
    "pairing": "...", 
    "summary": "...", 
    "tags": ["..."], 
    "rating": "G/T/M/E",
    "stats": {
        "hits": 1234,
        "kudos": 123,
        "bookmarks": 45,
        "comments": 12,
        "totalChapters": 15,
        "ending": "HE"
    }
  }
]`;
                     
                     const userPrompt = `User Keywords: ${prompt}`;
                     
                     const fullPrompt = `${systemPrompt}\n\n${userPrompt}`;
                     
                     const jsonStr = await callGeminiAPI(getFullPrompt(fullPrompt), true);
                     // æ¸…ç†å¯èƒ½å­˜åœ¨çš„ markdown æ ‡è®°
                     const cleanJson = jsonStr.replace(/```json/g, '').replace(/```/g, '').trim();
                     let rawBooks = JSON.parse(cleanJson);
                     
                     // å®¹é”™å¤„ç†ï¼šç¡®ä¿æ˜¯æ•°ç»„
                     if(!Array.isArray(rawBooks)) rawBooks = [rawBooks];

                     // é€‚é…å™¨ï¼šè½¬æ¢ä¸ºæ—§æ ¼å¼
                     books = rawBooks.map((b, idx) => ({
                        id: Date.now() + idx + Math.random(),
                        title: b.title,
                        author: b.pairing || "AI Writer",
                        genre: b.rating ? b.rating + "çº§" : "æœªçŸ¥",
                        words: (b.stats?.totalChapters || 15) * 3000,
                        score: b.stats ? ((b.stats.kudos / (b.stats.hits || 1)) * 10).toFixed(1) : "9.0",
                        intro: b.summary,
                        tags: b.tags || [],
                        status: b.stats?.ending ? "å·²å®Œç»“(" + b.stats.ending + ")" : "å·²å®Œç»“",
                        totalChapters: b.stats?.totalChapters || 15,
                        coverColor: `hsl(${Math.random() * 360}, 70%, 85%)`
                     }));
                     
                     // æ–°å¢ï¼šåŒæ­¥æ ‡ç­¾
                     syncTagsFromNewBooks(books);
                     
                 } catch(e) {
                     console.error(e);
                     alert("APIè°ƒç”¨å¤±è´¥ï¼Œå·²åˆ‡æ¢å›æ¨¡æ‹Ÿæ•°æ®ã€‚\né”™è¯¯ä¿¡æ¯: " + e.message);
                     books = mockAIResponse(prompt, state.generatedPages.length + 1);
                     syncTagsFromNewBooks(books);
                 }
            } else {
                await new Promise(r => setTimeout(r, 800));
                books = mockAIResponse(prompt, state.generatedPages.length + 1);
                syncTagsFromNewBooks(books);
            }

            state.generatedPages.push(books);
            state.currentPageIndex = state.generatedPages.length - 1;
            renderCurrentPage();
        }

        function renderCurrentPage() {
            const books = state.generatedPages[state.currentPageIndex];
            const container = document.getElementById('generatedResults');
            
            container.innerHTML = books.map(book => `
                <div class="book-preview-item" onclick='showBookDetail(${JSON.stringify(book).replace(/'/g, "&#39;")}, "home")'>
                    <div class="book-info">
                        <h3>${book.title}</h3>
                        <div class="book-meta">
                            [${book.genre}] | ${book.author} | ${book.score}åˆ† | ${(book.words/10000).toFixed(1)}ä¸‡å­— | <span style="color:darkred">å·²å®Œç»“</span>
                        </div>
                        <div class="book-intro">${book.intro}</div>
                    </div>
                </div>
            `).join('');

            document.getElementById('paginationControls').style.display = 'flex';
            document.getElementById('pageIndicator').innerText = `ç¬¬ ${state.currentPageIndex + 1} é¡µ`;
            document.getElementById('btnPrev').disabled = (state.currentPageIndex === 0);
            const btnNext = document.getElementById('btnNext');
            btnNext.innerText = "ä¸‹ä¸€é¡µ >";
            btnNext.disabled = false;
        }

        function changePage(delta) {
            const newIndex = state.currentPageIndex + delta;
            if (newIndex >= 0 && newIndex < state.generatedPages.length) {
                state.currentPageIndex = newIndex;
                renderCurrentPage();
            }
        }

        // ä¿®æ”¹ï¼šæ›´æ–°ä¹¦ç±å±æ€§ (å®Œç»“çŠ¶æ€, éšæœºç« èŠ‚)
        function mockAIResponse(prompt, pageNum) {
            const seed = Date.now();
            const genres = ["ä»™ä¾ ä¿®çœŸ", "ç°ä»£è¨€æƒ…", "å¹»æƒ³æœªæ¥", "æ‚¬ç–‘æƒŠæ‚š", "å¤æ—©ç‹—è¡€"];
            
            const prefixes = ["é‡ç”Ÿä¹‹", "ç©¿è¶Šå", "éœ‡æƒŠï¼", "ç©¿ä¹¦ä¹‹", "å¼€å±€", "ç»ä¸–", "è±ªé—¨", "æˆ‘åœ¨å¼‚ç•Œ", "æœ«ä¸–ä¹‹"];
            const suffixes = ["æ”»ç•¥", "æ—¥å¸¸", "æŒ‡å—", "è‡ªæ•‘ç³»ç»Ÿ", "ä¿®ä»™å½•", "å¤§å†’é™©", "ç”Ÿå­˜æ‰‹æœ­", "ä¸æƒ³åŠªåŠ›äº†"];
            const midFixes = ["å¤§ä½¬", "åæ´¾", "ç‚®ç°", "å¸ˆå°Š", "æ€»è£", "å½±å¸"];

            let mockBooks = [];
            const cleanPrompt = prompt.length > 5 ? prompt.substring(0, 4) + "..." : prompt;

            for(let i=0; i<5; i++) {
                const uniqueId = seed + i;
                let randTitle = "";
                const r = Math.random();
                if(r < 0.3) {
                    randTitle = prefixes[i % prefixes.length] + cleanPrompt;
                } else if (r < 0.6) {
                    randTitle = cleanPrompt + suffixes[i % suffixes.length];
                } else {
                    randTitle = cleanPrompt + "ä¸" + midFixes[i % midFixes.length] + "çš„" + suffixes[i % suffixes.length];
                }
                randTitle += (pageNum > 1 ? (" " + pageNum) : "");

                // ä¿®æ”¹ï¼šæ ¹æ®ç­›é€‰æ¨¡å¼ç”Ÿæˆç« èŠ‚æ•°
                let totalChaps;
                if (state.homeFilter === 'short') {
                    totalChaps = Math.floor(Math.random() * 8) + 1; // 1-8
                } else if (state.homeFilter === 'long') {
                    totalChaps = Math.floor(Math.random() * 18) + 8; // 8-25
                } else {
                    // mix: å‰2çŸ­ï¼Œå3é•¿
                    if (i < 2) totalChaps = Math.floor(Math.random() * 8) + 1;
                    else totalChaps = Math.floor(Math.random() * 18) + 8;
                }

                mockBooks.push({
                    id: uniqueId,
                    title: randTitle,
                    author: "æŠ˜é£AI-" + Math.floor(Math.random()*100),
                    genre: genres[(i + pageNum) % genres.length],
                    words: Math.floor(Math.random() * 500000) + 200000,
                    score: (Math.random() * 2 + 8).toFixed(1),
                    intro: `è¿™æ˜¯åŸºäºå…³é”®è¯â€œ${prompt}â€ç”Ÿæˆçš„æ–‡æ¡ˆã€‚ä¸»è§’åœ¨${prompt}çš„ä¸–ç•Œé‡Œæ‘¸çˆ¬æ»šæ‰“ï¼Œæœ€ç»ˆæˆä¸ºä¸€ä»£ä¼ å¥‡ã€‚è¿™æ˜¯ä¸€æ®µä¸ºäº†æ¼”ç¤ºé•¿æ–‡æœ¬æŠ˜å æ•ˆæœè€Œç”Ÿæˆçš„æ¨¡æ‹Ÿç®€ä»‹ã€‚\n\næ•…äº‹å‘ç”Ÿåœ¨ä¸€ä¸ªå……æ»¡å¥‡å¹»è‰²å½©çš„å¤§é™†ï¼Œä¸»è§’èº«è´Ÿè¡€æµ·æ·±ä»‡ï¼Œè¸ä¸Šäº†å¤ä»‡ä¹‹è·¯ã€‚é€”ä¸­ç»“è¯†äº†æ€§æ ¼å„å¼‚çš„ä¼™ä¼´ï¼Œç»å†äº†æ— æ•°ç”Ÿæ­»è€ƒéªŒã€‚æœ€ç»ˆï¼Œä¸»è§’ä¸ä»…æŠ¥äº†ä»‡ï¼Œè¿˜æ­å¼€äº†ä¸–ç•Œçš„çœŸç›¸ï¼Œæˆä¸ºäº†ä¼ è¯´ä¸­çš„è‹±é›„ã€‚\n\nè¿™æ®µæ–‡å­—å¤§çº¦æœ‰ä¸¤ç™¾å¤šå­—ï¼Œè¶³å¤Ÿåœ¨åˆ—è¡¨é¡µæ˜¾ç¤ºå‡ºæŠ˜å çš„æ•ˆæœï¼Œç‚¹å‡»è¿›å…¥è¯¦æƒ…é¡µåå¯ä»¥çœ‹åˆ°å®Œæ•´çš„å…¨éƒ¨å†…å®¹ã€‚æ­¤å¤–ï¼Œè¿˜åŒ…å«äº†ä¸€äº›å…³äºä¸–ç•Œè§‚çš„è¯¦ç»†æè¿°ï¼Œä»¥åŠä¸»è§’å†…å¿ƒçš„æŒ£æ‰ä¸æˆé•¿ï¼ŒåŠ›æ±‚è®©ç®€ä»‹çœ‹èµ·æ¥æ›´åŠ ä¸°æ»¡å’ŒçœŸå®ã€‚`,
                    tags: [prompt, "çˆ½æ–‡", "HE"],
                    status: "å·²å®Œç»“", // ä¿®æ”¹ï¼šå›ºå®šä¸ºå·²å®Œç»“
                    totalChapters: totalChaps, // ä¿®æ”¹ï¼šä¿å­˜ç« èŠ‚æ€»æ•°
                    coverColor: `hsl(${(seed * (i+1)) % 360}, 70%, 85%)`
                });
            }
            return mockBooks;
        }

        // ä¿®æ”¹ï¼šè¯¦æƒ…é¡µåŠ¨æ€æ¸²æŸ“ç« èŠ‚
        function showBookDetail(book, fromSource = 'home') {
            state.currentBook = book;
            state.detailSource = fromSource;
            const content = document.getElementById('bookDetailContent');
            const chapterList = document.getElementById('chapterList');

            // å¤„ç†è¿”å›æŒ‰é’®
            const backBtn = document.getElementById('btnBackToBookList');
            if(fromSource === 'bookshelf') {
                backBtn.setAttribute('onclick', "navTo('bookshelf')");
                backBtn.innerHTML = "&larr; è¿”å›ä¹¦æ¶";
            } else {
                backBtn.setAttribute('onclick', "navTo('home')");
                backBtn.innerHTML = "&larr; è¿”å›åˆ—è¡¨";
            }

            // ä¿®æ”¹ï¼šæ˜¾ç¤ºâ€œå·²å®Œç»“â€å’Œçº¢è‰²å­—ä½“
            content.innerHTML = `
                <div class="jj-detail-header">
                    <div class="jj-cover-lg" style="background:${book.coverColor || '#f0f0f0'}">
                        <div style="font-size:18px; font-weight:bold;">${book.title}</div>
                        <div style="font-size:12px; margin-top:10px;">${book.author} è‘—</div>
                    </div>
                    <div class="jj-meta-info">
                        <h1>${book.title} <span style="font-size:14px; color:gold;">VIP</span></h1>
                        <div class="jj-stat-row">ä½œè€…ï¼š${book.author}</div>
                        <div class="jj-stat-row">ç±»å‹ï¼š${book.genre}</div>
                        <div class="jj-stat-row">è¿›åº¦ï¼š<span style="color:darkred; font-weight:bold;">å·²å®Œç»“</span></div>
                        <div class="jj-stat-row">å…¨æ–‡å­—æ•°ï¼š${book.words} å­—</div>
                        <div class="jj-stat-row">ç« èŠ‚æ•°ï¼š${book.totalChapters} ç« </div>
                        <div class="jj-stat-row">è¯„åˆ†ï¼šâ­â­â­â­â­ ${book.score}</div>
                    </div>
                </div>
                <div class="jj-copy-box">${book.intro}</div>
                <div class="jj-tags">
                    <b>å†…å®¹æ ‡ç­¾ï¼š</b> ${book.tags.map(t => `<span class="jj-tag-item">[${t}]</span>`).join(' ')}
                </div>
            `;
            
            // ä¿®æ”¹ï¼šæ ¹æ® totalChapters å¾ªç¯ç”Ÿæˆç« èŠ‚åˆ—è¡¨
            let chapterHtml = '';
            const abandonedData = state.abandonedChapters[book.id] || {};

            for(let i = 1; i <= book.totalChapters; i++) {
                // å‰3ç« å…è´¹ï¼Œåé¢VIP
                const isVip = i > 3;
                chapterHtml += `
                    <div class="jj-chapter-row" onclick="startReading(${i})">
                        <span>ç¬¬${toChineseNum(i)}ç«  ${isVip ? 'VIPç« èŠ‚' : 'å…è´¹ç« èŠ‚'}</span>
                        <span class="${isVip ? 'jj-vip' : ''}">${isVip ? 'VIP' : 'å…è´¹'}</span>
                    </div>
                `;
                
                // æ˜¾ç¤ºåºŸå¼ƒç« èŠ‚
                if (abandonedData[i] && abandonedData[i].length > 0) {
                    abandonedData[i].forEach((item, idx) => {
                        const dateStr = new Date(item.timestamp).toLocaleString();
                        chapterHtml += `
                            <div class="abandoned-chapter-row" onclick="readAbandonedChapter(${i}, ${idx})">
                                <span><span class="abandoned-tag">åºŸå¼ƒ</span> ç‰ˆæœ¬ ${idx + 1} (${dateStr})</span>
                                <span>ğŸ—‘ï¸</span>
                            </div>
                        `;
                    });
                }
            }
            chapterList.innerHTML = chapterHtml;
            
            // æ›´æ–°å¼€å§‹é˜…è¯»æŒ‰é’®çŠ¶æ€
            const btnRead = document.getElementById('btnStartRead');
            if (btnRead) {
                const progress = state.readingProgress[book.id];
                if (progress) {
                    btnRead.innerText = `ç»§ç»­é˜…è¯» (ç¬¬${toChineseNum(progress)}ç« )`;
                    btnRead.setAttribute('onclick', `startReading(${progress})`);
                } else {
                    btnRead.innerText = "å¼€å§‹é˜…è¯»";
                    btnRead.setAttribute('onclick', `startReading(1)`);
                }
            }

            navTo('detail');
        }

        // --- é˜…è¯»å™¨é€»è¾‘ (å¤§å¹…æ›´æ–°) ---

        // è¿›å…¥é˜…è¯»æ¨¡å¼
        // forceRegenerate: æ˜¯å¦å¼ºåˆ¶é‡æ–°ç”Ÿæˆ
        // suggestion: ç”¨æˆ·ç»™å‡ºçš„å‰§æƒ…å»ºè®®
        // prevSummary: ä¸Šä¸€ç« çš„æ‘˜è¦ï¼ˆç”¨äºç”Ÿæˆæœ¬ç« çš„ä¸Šä¸‹æ–‡ï¼‰
        async function startReading(chapterNum, forceRegenerate = false, suggestion = "", prevSummary = "") {
            if(!state.currentBook) return;
            state.currentChapter = chapterNum;
            
            // è®°å½•é˜…è¯»è¿›åº¦
            state.readingProgress[state.currentBook.id] = chapterNum;
            localStorage.setItem('jj_reading_progress', JSON.stringify(state.readingProgress));

            // æ›´æ–°ä¹¦ç±æœ€åæ´»åŠ¨æ—¶é—´ (ç”¨äºä¹¦æ¶æ’åº)
            if (state.currentBook) {
                // æ›´æ–°å†…å­˜ä¸­çš„ä¹¦æ¶æ•°æ®
                const shelfIdx = state.bookshelf.findIndex(b => b.id === state.currentBook.id);
                if (shelfIdx !== -1) {
                    state.bookshelf[shelfIdx].lastUpdateTime = Date.now();
                    localStorage.setItem('jj_bookshelf', JSON.stringify(state.bookshelf));
                }
            }

            navTo('reader');
            
            const bookId = state.currentBook.id;
            const titleEl = document.getElementById('readerTitle');
            const bodyEl = document.getElementById('readerBody');
            const authorSayContent = document.getElementById('authorSayContent');
            const commentList = document.getElementById('commentList');
            
            // æ‚¬æµ®ç»„ä»¶åˆå§‹åŒ–
            document.querySelectorAll('.float-panel').forEach(el => el.classList.remove('active'));
            document.getElementById('plotSuggestion').value = ""; // æ¸…ç©ºå»ºè®®
            
            // éšè—ä½œè€…æœ‰è¯è¯´é¢æ¿ï¼ˆé»˜è®¤ï¼‰
            const panelAuthor = document.getElementById('panelAuthor');
            if(panelAuthor) panelAuthor.style.display = 'none';

            // é»˜è®¤æ ‡é¢˜
            let displayTitle = `ç¬¬${toChineseNum(chapterNum)}ç« `;
            
            // å°è¯•ä»ç¼“å­˜è·å–æ ‡é¢˜
            if (state.chapterTitles[bookId] && state.chapterTitles[bookId][chapterNum]) {
                let t = state.chapterTitles[bookId][chapterNum];
                // æ¸…æ´—æ ‡é¢˜ï¼Œå»é™¤å¯èƒ½å­˜åœ¨çš„ "ç¬¬xç« " å‰ç¼€
                t = t.replace(/^ç¬¬[0-9é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒ]+ç« \s*/, '');
                // å»é™¤ "Chapter X" å‰ç¼€
                t = t.replace(/^(Chapter|Vol|Episode)\s*\d+\s*[:ï¼š]?\s*/i, '');
                displayTitle += ` ${t}`;
            }
            
            titleEl.innerText = displayTitle;
            authorSayContent.innerHTML = '';
            commentList.innerHTML = '';

            // åŠ è½½æœ¬ç« æ‘˜è¦ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (!state.chapterSummaries[bookId]) state.chapterSummaries[bookId] = {};
            document.getElementById('chapterSummary').value = state.chapterSummaries[bookId][chapterNum] || "";
            
            // æ£€æŸ¥ç¼“å­˜
            if (!state.chapterCache[bookId]) state.chapterCache[bookId] = {};
            if (!state.chapterTitles[bookId]) state.chapterTitles[bookId] = {};
            if (!state.authorSays[bookId]) state.authorSays[bookId] = {};
            if (!state.comments[bookId]) state.comments[bookId] = {};

            // åŠ è½½å­—æ•°è®¾ç½®
            const settings = state.bookSettings[bookId] || {};
            document.getElementById('minWordCount').value = settings.minWords || 3000;

            // å¦‚æœæœ‰ç¼“å­˜ä¸”ä¸æ˜¯å¼ºåˆ¶é‡æ–°ç”Ÿæˆï¼Œç›´æ¥æ˜¾ç¤ºç¼“å­˜
            if (!forceRegenerate && state.chapterCache[bookId][chapterNum]) {
                bodyEl.innerHTML = state.chapterCache[bookId][chapterNum];
                
                // æ˜¾ç¤ºç¼“å­˜çš„ä½œè€…åè¯
                if (state.authorSays[bookId][chapterNum]) {
                    authorSayContent.innerText = state.authorSays[bookId][chapterNum];
                    if(panelAuthor) panelAuthor.style.display = 'block';
                }
                
                // æ˜¾ç¤ºç¼“å­˜çš„è¯„è®º
                renderComments(bookId, chapterNum);
                if (!state.comments[bookId][chapterNum] || state.comments[bookId][chapterNum].length === 0) {
                    loadMoreComments(); // å¦‚æœæ²¡æœ‰è¯„è®ºï¼Œè‡ªåŠ¨åŠ è½½ä¸€æ¬¡
                }

                updateNavButtons();
                return;
            }

            // å¦åˆ™è¿›è¡Œç”Ÿæˆ
            bodyEl.innerHTML = "<p style='color:#999; text-align:center;'>ä½œå®¶æ­£åœ¨ç«é€Ÿç¿»ç‚’ï¼Œæ–°é²œç¾å‘³çš„é¥­ç«é€Ÿèµ¶æ¥...</p>";
            updateNavButtons(true); // ç”Ÿæˆä¸­ç¦ç”¨æŒ‰é’®

            const result = await fetchChapterContent(state.currentBook, chapterNum, suggestion, prevSummary);
            
            // æ›´æ–°æ ‡é¢˜
            if (result.title) {
                let t = result.title;
                // æ¸…æ´—æ ‡é¢˜ï¼Œå»é™¤å¯èƒ½å­˜åœ¨çš„ "ç¬¬xç« " å‰ç¼€
                t = t.replace(/^ç¬¬[0-9é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒ]+ç« \s*/, '');
                // å»é™¤ "Chapter X" å‰ç¼€
                t = t.replace(/^(Chapter|Vol|Episode)\s*\d+\s*[:ï¼š]?\s*/i, '');
                
                state.chapterTitles[bookId][chapterNum] = t;
                localStorage.setItem('jj_chapter_titles', JSON.stringify(state.chapterTitles));
                titleEl.innerText = `ç¬¬${toChineseNum(chapterNum)}ç«  ${t}`;
            }

            // ç®€å•çš„æ‰“å­—æœºæ•ˆæœ
            bodyEl.innerHTML = "";
            const paragraphs = result.content.split('\n');
            let fullHtml = "";
            
            for(let p of paragraphs) {
                // é¢„å¤„ç†ï¼šç§»é™¤ markdown ä»£ç å—æ ‡è®°
                let cleanP = p.replace(/^```(html)?/i, '').replace(/```$/, '').trim();
                
                if(cleanP) {
                    // è¿‡æ»¤å­¤ç«‹çš„é—­åˆæ ‡ç­¾ (å¦‚ </div>)
                    if (/^<\/[a-z0-9]+>$/i.test(cleanP)) {
                        continue;
                    }

                    // è‡ªåŠ¨æ¸²æŸ“å™¨ï¼šæ£€æµ‹ HTML æ ‡ç­¾
                    // å¢å¼ºæ­£åˆ™ï¼šåŒ¹é… <tag> æˆ– </tag> æˆ– <tag />
                    const hasTag = /<\/?[a-z][\s\S]*>/i.test(cleanP);
                    
                    let pHtml;
                    const wrapper = document.createElement('div');
                    wrapper.style.marginBottom = '0.4em'; 
                    
                    if (hasTag) {
                        // å°è¯•ä½œä¸º HTML æ¸²æŸ“
                        wrapper.innerHTML = cleanP;
                        pHtml = `<div style="margin-bottom:0.4em">${cleanP}</div>`;
                    } else {
                        // çº¯æ–‡æœ¬
                        wrapper.innerText = cleanP;
                        pHtml = `<p>${cleanP}</p>`;
                    }
                    
                    fullHtml += pHtml;
                    bodyEl.appendChild(wrapper);
                    await new Promise(r => setTimeout(r, 20)); 
                }
            }

            // å­˜å…¥ç¼“å­˜
            state.chapterCache[bookId][chapterNum] = fullHtml;
            localStorage.setItem('jj_chapter_cache', JSON.stringify(state.chapterCache));
            
            // å¤„ç†ä½œè€…åè¯
            if (result.authorSay) {
                state.authorSays[bookId][chapterNum] = result.authorSay;
                localStorage.setItem('jj_author_says', JSON.stringify(state.authorSays));
                authorSayContent.innerText = result.authorSay;
                if(panelAuthor) panelAuthor.style.display = 'block';
                authorSayContent.classList.add('show');
            }

            // å¤„ç†AIç”Ÿæˆçš„è¯„è®º
            if (result.commentsRaw) {
                const lines = result.commentsRaw.split('\n').filter(l => l.trim());
                const newComments = lines.map(line => {
                    const parts = line.split(/[:ï¼š]/);
                    const user = parts[0].trim();
                    const text = parts.slice(1).join(':').trim();
                    return {
                        user: user || "åŒ¿åè¯»è€…",
                        text: text || line,
                        likes: Math.floor(Math.random() * 100)
                    };
                });
                
                if (!state.comments[bookId]) state.comments[bookId] = {};
                // è¦†ç›–æˆ–è¿½åŠ ï¼Ÿè¿™é‡Œé€‰æ‹©è¦†ç›–åˆå§‹è¯„è®ºï¼Œå› ä¸ºæ˜¯æ–°ç”Ÿæˆçš„
                state.comments[bookId][chapterNum] = newComments;
                localStorage.setItem('jj_comments', JSON.stringify(state.comments));
                renderComments(bookId, chapterNum);
            } else {
                // å¦‚æœæ²¡æœ‰AIè¯„è®ºï¼Œå°è¯•åŠ è½½æ›´å¤šï¼ˆå¯èƒ½ä¼šè§¦å‘APIç”Ÿæˆæˆ–æ¨¡æ‹Ÿï¼‰
                loadMoreComments();
            }

            updateNavButtons();
        }

        async function fetchChapterContent(book, chapterNum, suggestion, prevSummary) {
            // æå–ä¸Šä¸‹æ–‡ï¼šä¹¦åã€ç®€ä»‹ã€æ ‡ç­¾
            const contextText = `${book.title} ${book.intro} ${book.tags.join(' ')}`;
            const worldContext = getWorldContext(contextText);

            // è·å–å­—æ•°è®¾ç½® (é»˜è®¤å€¼ä¿®æ”¹ä¸º 3000)
            const minWords = state.bookSettings[book.id]?.minWords || 3000;

            // åˆ¤æ–­æ˜¯å¦æ˜¯ç»“å±€
            const isEnding = (chapterNum === book.totalChapters);
            const pacingInfo = isEnding ? 
                "è¿™æ˜¯å…¨ä¹¦çš„æœ€åä¸€ç« ï¼ˆå¤§ç»“å±€ï¼‰ã€‚è¯·åŠ¡å¿…è§„åˆ’å¥½æ•…äº‹çš„æ”¶æŸï¼Œè§£å†³ä¸»è¦å†²çªï¼Œäº¤ä»£ä¸»è¦è§’è‰²çš„å‘½è¿ï¼Œæä¾›ä¸€ä¸ªæ˜ç¡®ã€å®Œæ•´ä¸”ä»¤äººæ»¡æ„çš„ç»“å±€ã€‚" : 
                "å‰§æƒ…è¿è´¯ï¼Œæ¨è¿›æ•…äº‹å‘å±•ã€‚";

            // åŸºç¡€ Prompt
            const basePrompt = `[System Prompt]
You are writing "${book.title}" (Chapter ${chapterNum}).

ã€æ ¸å¿ƒä»»åŠ¡ã€‘
æ‰¿æ¥ã€å·²å‘å¸ƒç« èŠ‚å›é¡¾ã€‘ä¸­çš„æ‰€æœ‰å‰§æƒ…ã€ä¼ç¬”å’Œäººç‰©å…³ç³»ï¼Œæ’°å†™ä¸‹ä¸€ç« ã€‚
å¿…é¡»ä¿æŒäººç‰©æ€§æ ¼ä¸€è‡´ï¼Œé€»è¾‘è¿è´¯ï¼Œä¸¥æ ¼éµå®ˆä¸–ç•Œè§‚è®¾å®šã€‚
**ç‰¹åˆ«æ³¨æ„ï¼šå¦‚æœæä¾›äº†ã€ä½œè€…åˆ›ä½œæ„å›¾/ä¼ç¬”ã€‘ï¼Œå¿…é¡»åœ¨ç”Ÿæˆå†…å®¹ä¸­ä½“ç°æˆ–é“ºå«è¿™äº›æ„å›¾ï¼Œç¡®ä¿æƒ…èŠ‚èµ°å‘ç¬¦åˆä½œè€…è§„åˆ’ã€‚**

STORY INFO:
Summary: ${book.intro}
Tags: ${book.tags.join(', ')}
PACING: ${pacingInfo}

ORIGINAL USER REQUEST: "${suggestion || "æ— ç‰¹æ®Šè¦æ±‚ï¼Œè¯·æ ¹æ®å‰æ–‡ç»§ç»­åˆ›ä½œ"}"

CONTEXT DATA (World & Characters):
${worldContext || "æ— é¢å¤–ä¸–ç•Œè§‚è®¾å®š"}

${prevSummary || ""}

ã€è§†è§‰æ²‰æµ¸ (HTML)ã€‘
åœ¨æ­£æ–‡ä¸­ä½¿ç”¨ HTML div/span å¢å¼ºè¡¨ç°åŠ›ï¼ˆå¦‚ï¼š<div class="chat-bubble">...</div>, <p style="text-align:center">...</p >ï¼‰ã€‚
**IMPORTANT:** Do NOT wrap HTML in markdown code blocks (like \`\`\`html). Output raw HTML mixed with Markdown naturally so it renders directly.

REQUIREMENTS:
1. Language: Simplified Chinese (ç®€ä½“ä¸­æ–‡).
2. LENGTH: Main Content (excluding Author Note and Comments) MUST be STRICTLY longer than ${minWords} Chinese characters.
   - è¯·ç”Ÿæˆä¸€æ®µå®Œæ•´çš„æƒ…èŠ‚ï¼Œå†…å®¹é•¿åº¦éœ€ä¸¥æ ¼ä¿è¯åœ¨ ${minWords} å­—ä»¥ä¸Šã€‚
3. Style: AO3 Fanfiction style. Immersive and detailed.
4. Author Note: Simulate a real author's tone (like on Jinjiang/Lofter).
   - Tone: Natural, casual, friendly, and lively. Avoid stiff or robotic language.
   - Content: Can include plot analysis, character thoughts, next chapter preview, AND casual chat (e.g., asking for comments, sharing writing feelings, thanking readers).
   - Make it feel like a real person communicating with readers.
5. Comments: You are simulating an AO3/Lofter/Forum comment section. Generate 5 NEW, distinct comments.
ROLEPLAY INSTRUCTION:
You are NOT an AI assistant. You are a real reader reading this fiction.
- React to specific plot points in the excerpt.
- Scream about the CP (Shipping).
- Cry about the angst.
- Or complain if the villain is too hateful.
- Use internet slang (e.g. kswl, å¤ªå¤ªé¥¿é¥¿é¥­é¥­, åˆ€å‚»äº†).
Strictly Simplified Chinese.
Generate varied timestamps (date) that look realistic.

6. Output strictly JSON:
{
  "title": "Chapter Title",
  "content": "Markdown text with embedded HTML (NO code blocks around HTML)...",
  "authorNote": "...",
  "comments": [ { "author": "...", "content": "...", "language": "zh", "date": "..." } ]
}`;

            let resultData = null;
            let rawText = "";
            let bodyContent = "";
            let title = "";
            let authorSay = "";
            let commentsRaw = "";

            if (state.config.apiKey) {
                try {
                     // è®¡ç®— maxOutputTokens (ç›®æ ‡å­—æ•° * 2 ä½œä¸ºç¼“å†²ï¼Œè‡³å°‘ 8192)
                     const maxTokens = Math.max(8192, parseInt(minWords) * 2);
                     
                     // ä½¿ç”¨ JSON æ¨¡å¼è°ƒç”¨ API
                     rawText = await callGeminiAPI(getFullPrompt(basePrompt), {
                         jsonMode: true,
                         generationConfig: { maxOutputTokens: maxTokens }
                     });
                     
                     // æ¸…ç†å¯èƒ½å­˜åœ¨çš„ markdown æ ‡è®°
                     const cleanJson = rawText.replace(/```json/g, '').replace(/```/g, '').trim();
                     resultData = JSON.parse(cleanJson);
                     
                     if (resultData) {
                        title = resultData.title || `ç¬¬${chapterNum}ç« `;
                        // åº”ç”¨æ­£åˆ™åå¤„ç†
                        bodyContent = applyActiveRegexRules(resultData.content || "");
                        authorSay = resultData.authorNote || "";
                        if (resultData.comments && Array.isArray(resultData.comments)) {
                            commentsRaw = resultData.comments.map(c => `${c.author}: ${c.content}`).join('\n');
                        }
                     }

                     // --- æ ¡éªŒä¸è‡ªåŠ¨è¡¥å¿ (ç»­å†™) ---
                     let currentLength = bodyContent.length;
                     let retryCount = 0;
                     const maxRetries = 3;

                     while (currentLength < minWords && retryCount < maxRetries) {
                         console.log(`å­—æ•°ä¸è¶³ (${currentLength}/${minWords})ï¼Œè§¦å‘è‡ªåŠ¨ç»­å†™... ç¬¬ ${retryCount+1} æ¬¡`);
                         
                         const continuePrompt = `[System Instruction]
The previous generated content length (${currentLength} chars) is NOT enough. The target is STRICTLY ${minWords} chars.
You MUST continue writing the story from where it stopped to meet the length requirement.

INSTRUCTIONS:
1. Continue the plot naturally. Do NOT repeat previous content.
2. Write at least ${minWords - currentLength + 500} more Chinese characters.
3. Maintain the same style, tone, and context.
4. Output strictly JSON with a single field "content" containing ONLY the NEWLY ADDED text:
{
  "content": "..."
}`;
                         // ç»­å†™è¯·æ±‚
                         const continueJson = await callGeminiAPI(getFullPrompt(continuePrompt), {
                             jsonMode: true,
                             generationConfig: { maxOutputTokens: 4096 }
                         });
                         
                         try {
                             const cleanContinue = continueJson.replace(/```json/g, '').replace(/```/g, '').trim();
                             const continueData = JSON.parse(cleanContinue);
                             if (continueData && continueData.content) {
                                 bodyContent += "\n" + continueData.content;
                                 currentLength = bodyContent.length;
                             }
                         } catch (err) {
                             console.error("ç»­å†™è§£æå¤±è´¥", err);
                         }
                         
                         retryCount++;
                     }

                } catch(e) {
                     console.error("ç”Ÿæˆå¤±è´¥", e);
                     rawText = "ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–Keyé…ç½®ã€‚\né”™è¯¯ä¿¡æ¯: " + e.message;
                     bodyContent = rawText;
                }
            } else {
                // æ¨¡æ‹Ÿæ¨¡å¼
                await new Promise(r => setTimeout(r, 1000));
                resultData = {
                    title: "æ¨¡æ‹Ÿç« èŠ‚æ ‡é¢˜",
                    content: "TITLE: å‘½è¿çš„é½¿è½®\n" + mockChapterText(chapterNum, book),
                    authorNote: "ï¼ˆæ¨¡æ‹Ÿï¼‰ä½œè€…æœ‰è¯è¯´ï¼šæœ¬ç« å‰§æƒ…ç¨å¾®æœ‰ç‚¹è™ï¼Œå¤§å®¶æŒºä½ï¼ä¸‹ä¸€ç« ä¸»è§’å°±è¦å¼€å§‹åå‡»äº†ï¼Œæ•¬è¯·æœŸå¾…ï¼æ±‚æ”¶è—æ±‚è¯„è®º~",
                    comments: [
                        { author: "ç”¨æˆ·1", content: "æ¨¡æ‹Ÿè¯„è®º1" },
                        { author: "ç”¨æˆ·2", content: "æ¨¡æ‹Ÿè¯„è®º2" }
                    ]
                };
                title = resultData.title;
                bodyContent = resultData.content;
                authorSay = resultData.authorNote;
                commentsRaw = resultData.comments.map(c => `${c.author}: ${c.content}`).join('\n');
            }

            return {
                title: title,
                content: bodyContent,
                authorSay: authorSay || "ï¼ˆä½œè€…å¤ªç´¯äº†ï¼Œæ²¡æœ‰ç•™ä¸‹åè¯ï¼‰",
                commentsRaw: commentsRaw
            };
        }

        function mockChapterText(chapterNum, book) {
            return `    ç¬¬${chapterNum}ç« çš„é’Ÿå£°æ•²å“äº†ã€‚\n
    å¯¹äº${book.title}ä¸­çš„ä¸»è§’æ¥è¯´ï¼Œè¿™åˆæ˜¯æ–°çš„ä¸€å¤©ã€‚åœ¨ç»å†äº†å‰å‡ ç« çš„æ³¢æŠ˜åï¼Œå‰§æƒ…æ¥åˆ°äº†ç¬¬${chapterNum}ç« çš„å…³é”®èŠ‚ç‚¹ã€‚\n
    å‘¨å›´çš„ç¯å¢ƒå‘ç”Ÿäº†ä¸€äº›å¾®å¦™çš„å˜åŒ–ï¼Œä»¿ä½›é¢„ç¤ºç€æ¥ä¸‹æ¥çš„æ•…äº‹å°†æ›´åŠ æ‰£äººå¿ƒå¼¦ã€‚${book.genre}ä¸–ç•Œçš„è§„åˆ™ä¾ç„¶åœ¨å†·é…·åœ°è¿è½¬ã€‚\n
    â€œæˆ‘ä»¬ä¸èƒ½åœä¸‹ã€‚â€é…è§’åœ¨ä¸€æ—è¯´é“ï¼Œç¥è‰²å‡é‡ã€‚\n
    ä¸»è§’ç‚¹äº†ç‚¹å¤´ï¼Œçœ‹å‘è¿œæ–¹ï¼šâ€œæˆ‘çŸ¥é“ï¼Œè¿™åªæ˜¯åˆšåˆšå¼€å§‹ã€‚â€\n
    ï¼ˆæ­¤å¤„ä¸ºAIç”Ÿæˆçš„æ¨¡æ‹Ÿæ­£æ–‡å†…å®¹ã€‚ç³»ç»Ÿå·²å°†æœ¬ç« å†…å®¹ç¼“å­˜ï¼Œæ‚¨ç‚¹å‡»ä¸Šä¸€ç« å†å›æ¥ï¼Œå†…å®¹ä¾ç„¶æ˜¯è¿™æ®µã€‚ç‚¹å‡»å³ä¸Šè§’â€œé‡æ–°ç”Ÿæˆâ€å¯è¦†ç›–æ­¤å†…å®¹ã€‚ï¼‰\n
    éšç€æ—¶é—´çš„æ¨ç§»ï¼ŒçœŸç›¸ä¼¼ä¹è¶Šæ¥è¶Šè¿‘ï¼Œåˆä¼¼ä¹è¶Šæ¥è¶Šè¿œã€‚å‘½è¿çš„é½¿è½®è¿˜åœ¨è½¬åŠ¨ï¼Œè°ä¹Ÿæ— æ³•é¢„çŸ¥ç»“å±€ã€‚`;
        }

        // ä¸Šä¸€ç« 
        function prevChapter() {
            if(state.currentChapter > 1) {
                startReading(state.currentChapter - 1);
            }
        }

        // ä¸‹ä¸€ç« 
        function nextChapter() {
            if(state.currentChapter < state.currentBook.totalChapters) {
                const suggestion = document.getElementById('plotSuggestion').value;
                
                // --- ä¸Šä¸‹æ–‡åˆ†å‘é€»è¾‘é‡æ„ (éœ€æ±‚3) ---
                const bookId = state.currentBook.id;
                const currentNum = state.currentChapter;
                
                // ç»„è£…å‰æƒ…æè¦ï¼šéå†æ‰€æœ‰å·²å­˜åœ¨çš„ç« èŠ‚ï¼ˆä»ç¬¬ä¸€ç« åˆ°å½“å‰ç« ï¼‰
                let contextParts = [];
                
                for (let i = 1; i <= currentNum; i++) {
                    // 1. åˆ¤æ–­æ˜¯å¦æœ‰æ‘˜è¦
                    // ä¼˜å…ˆå–å†…å­˜/DOMä¸­çš„æœ€æ–°å€¼ï¼ˆå¦‚æœæ˜¯å½“å‰ç« ï¼‰
                    let summary = state.chapterSummaries[bookId]?.[i];
                    if (i === currentNum) {
                        const domVal = document.getElementById('chapterSummary').value;
                        if (domVal) summary = domVal;
                    }

                    if (summary && summary.trim()) {
                        contextParts.push(`ã€ç¬¬${i}ç« æ‘˜è¦ã€‘ï¼š\n${summary}`);
                    } else {
                        // 2. è‹¥æ— æ‘˜è¦ï¼Œå–æ­£æ–‡
                        let content = state.chapterCache[bookId]?.[i] || "";
                        if (content) {
                            // ç®€å•çš„HTMLè½¬æ–‡æœ¬ï¼Œä¿ç•™æ¢è¡Œ
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = content;
                            let plainText = tempDiv.innerText;
                            contextParts.push(`ã€ç¬¬${i}ç« æ­£æ–‡ã€‘ï¼š\n${plainText}`);
                        }
                    }
                }

                const prevContext = contextParts.join('\n\n');
                
                // ä¼ é€’ç»™ä¸‹ä¸€ç« ç”Ÿæˆ
                startReading(state.currentChapter + 1, false, suggestion, prevContext);
            }
        }

        function generateSideStory() {
            if(!confirm("æ­å–œå®Œç»“ï¼è¦ä¸ºè¿™æœ¬ä¹¦ç”Ÿæˆä¸€ç¯‡ç•ªå¤–å—ï¼Ÿ")) return;
            
            // å¢åŠ ç« èŠ‚æ•°
            state.currentBook.totalChapters++;
            // æ›´æ–°ä¹¦æ¶ä¸­çš„æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰
            const shelfIdx = state.bookshelf.findIndex(b => b.id === state.currentBook.id);
            if(shelfIdx !== -1) {
                state.bookshelf[shelfIdx].totalChapters = state.currentBook.totalChapters;
                localStorage.setItem('jj_bookshelf', JSON.stringify(state.bookshelf));
            }
            
            // è·³è½¬é˜…è¯»
            const suggestion = document.getElementById('plotSuggestion').value || "ç”œç”œçš„å©šåæ—¥å¸¸/å¹³è¡Œä¸–ç•Œ/é…è§’æ•…äº‹";
            const prevSummary = state.chapterSummaries[state.currentBook.id]?.[state.currentChapter] || "";
            
            // æ ‡è®°è¿™æ˜¯ç•ªå¤–
            startReading(state.currentBook.totalChapters, false, "ã€ç•ªå¤–ç¯‡ã€‘" + suggestion, prevSummary);
        }

        function saveWordCountSetting() {
            if(!state.currentBook) return;
            const val = parseInt(document.getElementById('minWordCount').value) || 3000;
            if(!state.bookSettings[state.currentBook.id]) state.bookSettings[state.currentBook.id] = {};
            state.bookSettings[state.currentBook.id].minWords = val;
            localStorage.setItem('jj_book_settings', JSON.stringify(state.bookSettings));
        }

        function deleteCurrentChapter() {
            if(!state.currentBook) return;
            if(!confirm("ç¡®å®šè¦åˆ é™¤å½“å‰ç« èŠ‚å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚")) return;

            const bookId = state.currentBook.id;
            const chapterNum = state.currentChapter;

            // 1. æ¸…é™¤æ•°æ®
            if(state.chapterCache[bookId]) delete state.chapterCache[bookId][chapterNum];
            if(state.chapterTitles[bookId]) delete state.chapterTitles[bookId][chapterNum];
            if(state.authorSays[bookId]) delete state.authorSays[bookId][chapterNum];
            if(state.comments[bookId]) delete state.comments[bookId][chapterNum];
            if(state.chapterSummaries[bookId]) delete state.chapterSummaries[bookId][chapterNum];
            
            // 2. ä¿å­˜åˆ° localStorage
            localStorage.setItem('jj_chapter_cache', JSON.stringify(state.chapterCache));
            localStorage.setItem('jj_chapter_titles', JSON.stringify(state.chapterTitles));
            localStorage.setItem('jj_author_says', JSON.stringify(state.authorSays));
            localStorage.setItem('jj_comments', JSON.stringify(state.comments));
            localStorage.setItem('jj_chapter_summaries', JSON.stringify(state.chapterSummaries));

            // 3. å¦‚æœæ˜¯æœ€åä¸€ç« ï¼Œå‡å°‘æ€»ç« èŠ‚æ•°
            if (chapterNum === state.currentBook.totalChapters && state.currentBook.totalChapters > 1) {
                state.currentBook.totalChapters--;
                // æ›´æ–°ä¹¦æ¶
                const shelfIdx = state.bookshelf.findIndex(b => b.id === bookId);
                if(shelfIdx !== -1) {
                    state.bookshelf[shelfIdx].totalChapters = state.currentBook.totalChapters;
                    localStorage.setItem('jj_bookshelf', JSON.stringify(state.bookshelf));
                }
            }

            alert("ç« èŠ‚å·²åˆ é™¤");
            // 4. è·³è½¬
            if (chapterNum > 1) {
                startReading(chapterNum - 1);
            } else {
                navTo('detail');
            }
        }

        // é‡æ–°ç”Ÿæˆå½“å‰ç« 
        function regenerateCurrentChapter() {
            if(confirm("ç¡®å®šè¦é‡æ–°ç”Ÿæˆæœ¬ç« å†…å®¹å—ï¼Ÿå½“å‰ç‰ˆæœ¬å°†ç§»å…¥åºŸå¼ƒç›®å½•ã€‚")) {
                const bookId = state.currentBook.id;
                const chapterNum = state.currentChapter;
                
                // ä¿å­˜å½“å‰ç‰ˆæœ¬åˆ°åºŸå¼ƒåˆ—è¡¨
                if (state.chapterCache[bookId] && state.chapterCache[bookId][chapterNum]) {
                    if (!state.abandonedChapters[bookId]) state.abandonedChapters[bookId] = {};
                    if (!state.abandonedChapters[bookId][chapterNum]) state.abandonedChapters[bookId][chapterNum] = [];
                    
                    state.abandonedChapters[bookId][chapterNum].push({
                        content: state.chapterCache[bookId][chapterNum],
                        authorSay: state.authorSays[bookId] ? state.authorSays[bookId][chapterNum] : "",
                        title: state.chapterTitles[bookId] ? state.chapterTitles[bookId][chapterNum] : "",
                        timestamp: Date.now()
                    });
                    localStorage.setItem('jj_abandoned_chapters', JSON.stringify(state.abandonedChapters));
                }

                const suggestion = document.getElementById('plotSuggestion').value;
                const prevSummary = state.chapterSummaries[bookId]?.[state.currentChapter - 1] || "";
                startReading(state.currentChapter, true, suggestion, prevSummary);
            }
        }

        // é˜…è¯»åºŸå¼ƒç« èŠ‚
        function readAbandonedChapter(chapterNum, index) {
            const bookId = state.currentBook.id;
            const item = state.abandonedChapters[bookId][chapterNum][index];
            if (!item) return;

            navTo('reader');
            
            let displayTitle = `ç¬¬${toChineseNum(chapterNum)}ç« `;
            if (item.title) displayTitle += ` ${item.title}`;
            displayTitle += ` (åºŸå¼ƒç‰ˆæœ¬ ${index + 1})`;
            
            document.getElementById('readerTitle').innerText = displayTitle;
            document.getElementById('readerBody').innerHTML = item.content;
            
            // æ˜¾ç¤ºåºŸå¼ƒç‰ˆæœ¬çš„ä½œè€…åè¯
            const authorSayContent = document.getElementById('authorSayContent');
            const panelAuthor = document.getElementById('panelAuthor');
            if (item.authorSay) {
                authorSayContent.innerText = item.authorSay;
                if(panelAuthor) panelAuthor.style.display = 'block';
            } else {
                authorSayContent.innerText = "";
                if(panelAuthor) panelAuthor.style.display = 'none';
            }

            // éšè—è¯„è®ºåŒºå’Œæ“ä½œæŒ‰é’®ï¼Œé¿å…æ··æ·†
            document.getElementById('commentList').innerHTML = '<div style="text-align:center; color:#999;">å†å²ç‰ˆæœ¬ä¸æ”¯æŒè¯„è®º</div>';
            document.getElementById('btnNextChapter').disabled = true;
            document.getElementById('btnNextChapter').innerText = "å†å²ç‰ˆæœ¬æ¨¡å¼";
        }

        // ç›®å½•å¼¹çª—æ§åˆ¶
        function toggleReaderCatalog() {
            const modal = document.getElementById('readerCatalogModal');
            if (modal.style.display === 'flex') {
                modal.style.display = 'none';
                modal.classList.remove('active');
            } else {
                renderReaderCatalog();
                modal.style.display = 'flex';
                // å¼ºåˆ¶é‡ç»˜ä»¥è§¦å‘è¿‡æ¸¡åŠ¨ç”»
                requestAnimationFrame(() => {
                    modal.classList.add('active');
                });
            }
        }

        // å…¨å±€ç‚¹å‡»ç›‘å¬ï¼šå¤„ç†æ‚¬æµ®é¢æ¿å…³é—­
        document.addEventListener('click', function(e) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯æ‚¬æµ®æŒ‰é’®æœ¬èº«ï¼Œä¸å¤„ç†ï¼ˆç”±æŒ‰é’®è‡ªå·±çš„ onclick å¤„ç†ï¼‰
            if (e.target.closest('.float-btn')) return;
            
            // å¦‚æœç‚¹å‡»çš„æ˜¯é¢æ¿å†…éƒ¨ï¼Œä¸å¤„ç†
            if (e.target.closest('.float-panel')) return;
            
            // å¦åˆ™ï¼Œå…³é—­æ‰€æœ‰é¢æ¿
            document.querySelectorAll('.float-panel.active').forEach(panel => {
                panel.classList.remove('active');
            });
        });

        function renderReaderCatalog() {
            if (!state.currentBook) return;
            const bookId = state.currentBook.id;
            const listEl = document.getElementById('readerCatalogList');
            const total = state.currentBook.totalChapters;
            const abandonedData = state.abandonedChapters[bookId] || {};
            
            let html = '';
            for (let i = 1; i <= total; i++) {
                const title = state.chapterTitles[bookId]?.[i] || "";
                const isActive = (i === state.currentChapter);
                const hasContent = !!state.chapterCache[bookId]?.[i];
                
                // æ­£å¸¸ç« èŠ‚
                // å·²ç”Ÿæˆç« èŠ‚ï¼šæ˜¾ç¤ºæ ¼å¼ä¸ºâ€œç¬¬Xç«  æ ‡é¢˜â€
                // æœªç”Ÿæˆç« èŠ‚ï¼šä»…æ˜¾ç¤ºç« èŠ‚æ•°å­—
                let displayTitle = `ç¬¬${toChineseNum(i)}ç« `;
                if (hasContent && title) {
                    displayTitle += ` ${title}`;
                }
                
                html += `
                    <div class="catalog-item ${isActive ? 'active' : ''}" onclick="startReading(${i}); toggleReaderCatalog();">
                        ${displayTitle}
                    </div>
                `;
                
                // åºŸå¼ƒç« èŠ‚
                if (abandonedData[i] && abandonedData[i].length > 0) {
                    abandonedData[i].forEach((item, idx) => {
                        // åºŸå¼ƒç« èŠ‚ï¼šåœ¨æ ‡é¢˜åè¿½åŠ æ ‡è¯†â€œ0.5â€
                        let abandonedTitle = `ç¬¬${toChineseNum(i)}ç« `;
                        if (item.title) abandonedTitle += ` ${item.title}`;
                        abandonedTitle += ` 0.5 (åºŸå¼ƒç‰ˆ${idx+1})`;

                        html += `
                            <div class="catalog-item abandoned" onclick="readAbandonedChapter(${i}, ${idx}); toggleReaderCatalog();">
                                ${abandonedTitle}
                            </div>
                        `;
                    });
                }
            }
            listEl.innerHTML = html;
        }

        // åŠ è½½æ›´å¤šè¯„è®º
        async function loadMoreComments() {
            const bookId = state.currentBook.id;
            const chapterNum = state.currentChapter;
            const btn = document.querySelector('.comment-action .btn');
            if(btn) {
                btn.innerText = "åŠ è½½ä¸­...";
                btn.disabled = true;
            }

            let newComments = [];

            // å¦‚æœæœ‰API Keyä¸”æœ‰ç« èŠ‚å†…å®¹ï¼Œå°è¯•ç”¨APIç”Ÿæˆ
            const content = state.chapterCache[bookId]?.[chapterNum];
            if (state.config.apiKey && content) {
                try {
                    // æå–çº¯æ–‡æœ¬å†…å®¹ç”¨äºprompt
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = content;
                    const plainText = tempDiv.innerText.substring(0, 2000); // é™åˆ¶é•¿åº¦

                    const prompt = `è¯·æ ¹æ®ä»¥ä¸‹å°è¯´ç« èŠ‚å†…å®¹ï¼Œç”Ÿæˆ 3 æ¡æ–°çš„è¯»è€…è¯„è®ºã€‚
                    è¦æ±‚ï¼š
                    1. **å†…å®¹ç›¸å…³æ€§**ï¼šè¯„è®ºå¿…é¡»ç´§æ‰£æœ¬ç« çš„å…·ä½“å‰§æƒ…ã€äººç‰©å¯¹è¯æˆ–ç»†èŠ‚ï¼Œä¸¥ç¦ç”Ÿæˆé€šç”¨çš„â€œå¥½çœ‹â€ã€â€œæ‰“å¡â€ç­‰æ— æ„ä¹‰è¯„è®ºã€‚
                    2. **è¯„è®ºè§†è§’**ï¼šæ¨¡æ‹ŸçœŸå®çš„æŠ˜é£è¯»è€…è¯­æ°”ï¼Œé£æ ¼è¦å¤šæ ·åŒ–ï¼š
                       - æƒ…æ„Ÿäº®ç‚¹ï¼ˆç³–ç‚¹ï¼‰ï¼šå¦‚â€œå•Šå•Šå•Šå¤ªç”œäº†â€ã€â€œå—‘æ­»æˆ‘äº†â€ã€‚
                       - äº’åŠ¨è¶£å‘³ï¼ˆç£•ç‚¹ï¼‰ï¼šåˆ†æä¸»è§’äº’åŠ¨ç»†èŠ‚ã€‚
                       - æƒ…èŠ‚çˆ½æ„Ÿï¼ˆçˆ½ç‚¹ï¼‰ï¼šå¦‚â€œæ‰“è„¸å¤ªçˆ½äº†â€ã€â€œç»ˆäºç­‰åˆ°è¿™ä¸€å¤©â€ã€‚
                       - åæ§½æˆ–ç©æ¢—ã€‚
                    3. **å­—æ•°èŒƒå›´**ï¼šæ¯æ¡è¯„è®ºçš„å†…å®¹åº”åœ¨ 80å­—è‡³180å­— ä¹‹é—´ã€‚
                    4. æ ¼å¼ä¸ºçº¯æ–‡æœ¬ï¼Œæ¯è¡Œä¸€æ¡ï¼š "ç”¨æˆ·ID: è¯„è®ºå†…å®¹"
                    5. è¯„è®ºå†…å®¹ä¸è¦é‡å¤ï¼Œä¸è¦åŒè´¨åŒ–ã€‚
                    
                    ç« èŠ‚å†…å®¹ç‰‡æ®µï¼š
                    ${plainText}`;

                    const raw = await callGeminiAPI(getFullPrompt(prompt));
                    const lines = raw.split('\n').filter(l => l.trim());
                    newComments = lines.map(line => {
                        const parts = line.split(/[:ï¼š]/);
                        return {
                            user: parts[0].trim() || "çƒ­å¿ƒç½‘å‹",
                            text: parts.slice(1).join(':').trim() || line,
                            likes: Math.floor(Math.random() * 50)
                        };
                    });

                } catch(e) {
                    console.error("è¯„è®ºç”Ÿæˆå¤±è´¥ï¼Œè½¬ä¸ºæ¨¡æ‹Ÿ", e);
                    newComments = generateMockComments(3);
                }
            } else {
                newComments = generateMockComments(3);
            }
            
            if (!state.comments[bookId]) state.comments[bookId] = {};
            if (!state.comments[bookId][chapterNum]) state.comments[bookId][chapterNum] = [];
            
            state.comments[bookId][chapterNum].push(...newComments);
            localStorage.setItem('jj_comments', JSON.stringify(state.comments));
            
            renderComments(bookId, chapterNum);
            
            if(btn) {
                btn.innerText = "æŸ¥çœ‹æ›´å¤šè¯„è®º";
                btn.disabled = false;
            }
        }

        function generateMockComments(count) {
            const users = ["å—‘å­¦å®¶", "æ˜¾å¾®é•œå¥³å­©", "æ°‘æ”¿å±€æ¬æ¥äº†", "åˆ€ç‰‡å¯„é€è€…", "çº¯çˆ±æˆ˜ç¥", "åˆ—æ–‡è™å…‹", "æŒ‰å¤´å°åˆ†é˜Ÿ", "é«˜ä¸¾å¤§æ——", "æ·±æ°´é±¼é›·", "è¥å…»æ¶²çŒæº‰æœº"];
            const part1 = [
                "å•Šå•Šå•Šå•Šå•Šï¼è¿™ä¸€ç« ä¹Ÿå¤ªå¥½çœ‹äº†å§ï¼æˆ‘ç›´æ¥å°–å«é¸¡ï¼",
                "æ•‘å‘½ï¼Œè¿™æ˜¯ä»€ä¹ˆç¥ä»™çˆ±æƒ…ï¼Ÿè™½ç„¶æœ‰ç‚¹è™ï¼Œä½†æ˜¯ç»ç’ƒæ¸£é‡Œæ‰¾ç³–åƒæˆ‘ä¹Ÿæ„¿æ„ï¼",
                "ç»†èŠ‚å¥½è¯„ï¼æ³¨æ„åˆ°äº†å—ï¼Œä¸»è§’åˆšæ‰é‚£ä¸ªåŠ¨ä½œæ˜æ˜¾æ˜¯ä¸‹æ„è¯†çš„ä¿æŠ¤ï¼Œè¿™è¿˜ä¸æ˜¯çˆ±ï¼Ÿ",
                "åˆ†æä¸€ä¸‹å‰§æƒ…ï¼šä¼ç¬”å›æ”¶äº†ï¼ä¹‹å‰ç¬¬ä¸‰ç« æåˆ°çš„é‚£ä¸ªç‰ä½©æœç„¶æ˜¯å…³é”®é“å…·ã€‚",
                "å‘œå‘œå‘œï¼Œæˆ‘çš„çœ¼æ³ªä¸å€¼é’±ã€‚çœ‹åˆ°è¿™é‡ŒçœŸçš„ç ´é˜²äº†ï¼Œä¸ºä»€ä¹ˆç›¸çˆ±çš„äººè¦äº’ç›¸æŠ˜ç£¨ï¼Ÿ",
                "è¿™å¯¹CPæˆ‘å—‘çˆ†ï¼è¿™ç§æ‹‰æ‰¯æ„ŸçœŸçš„ç»äº†ï¼Œä½œè€…å¤§å¤§å¤ªä¼šå†™äº†ã€‚",
                "è™½ç„¶ä½†æ˜¯ï¼Œåæ´¾ä¹Ÿæœ‰ç‚¹è¿·äººæ˜¯æ€ä¹ˆå›äº‹ï¼Ÿæ„Ÿè§‰åæ´¾èƒŒåä¹Ÿæœ‰æ•…äº‹å•Šã€‚",
                "è¿™ä¸€ç« çš„ä¿¡æ¯é‡å¥½å¤§ï¼æ„Ÿè§‰ä¹‹å‰çš„æ¨æµ‹éƒ½è¦æ¨ç¿»äº†ã€‚",
                "å¤ªç”œäº†å¤ªç”œäº†ï¼è¿™ç§åŒå‘å¥”èµ´çš„å‰§æƒ…æˆ‘æœ€çˆ±äº†ã€‚",
                "å¤§å¤§ä½ çš„æ‰‹æ˜¯å€Ÿæ¥çš„å—ï¼Ÿæ€ä¹ˆèƒ½å†™å‡ºè¿™ä¹ˆæœ‰ç”»é¢æ„Ÿçš„æ–‡å­—ï¼"
            ];
            const part2 = [
                "ä¸»è§’ä¹‹é—´çš„å¼ åŠ›æ‹‰æ»¡äº†ï¼Œç‰¹åˆ«æ˜¯é‚£ä¸ªçœ¼ç¥ï¼Œæˆ‘æ­»äº†ï¼è¿™éƒ½ä¸ç»“å©šå¾ˆéš¾æ”¶åœºå•Šï¼",
                "å¤§å¤§å¿«æ›´ï¼Œç”Ÿäº§é˜Ÿçš„é©´éƒ½ä¸æ•¢è¿™ä¹ˆæ­‡ï¼è¥å…»æ¶²éƒ½ç»™ä½ ï¼Œå¿«æŠŠä¸‹ä¸€ç« äº¤å‡ºæ¥ï¼",
                "è¿™ç§éšå¿çš„çˆ±æ„æ¯”ç›´æ¥è¯´å‡ºæ¥æ›´åŠ¨äººï¼Œå“ï¼Œç»†å“ï¼æˆ‘å·²ç»è„‘è¡¥äº†ä¸€ä¸‡å­—ç•ªå¤–äº†ã€‚",
                "æ„Ÿè§‰ä¸‹ä¸€ç« è¦æå¤§äº‹ï¼ŒæœŸå¾…æ‰“è„¸æƒ…èŠ‚ï¼å¸Œæœ›ä¸»è§’èƒ½æ”¯æ£±èµ·æ¥ï¼Œç»™åæ´¾ä¸€ç‚¹é¢œè‰²çœ‹çœ‹ã€‚",
                "å¸Œæœ›åé¢èƒ½ç”œä¸€ç‚¹ï¼Œå­©å­è¦é¥¿æ­»äº†ã€‚ä¿¡å¥³æ„¿ä¸€ç”Ÿè¤ç´ æ­é…æ¢ä»–ä»¬ä¸€ä¸ªHEã€‚",
                "ä¸è¿‡è¿˜æ˜¯ç«™å®˜é…ï¼Œé”æ­»ï¼é’¥åŒ™æˆ‘åäº†ï¼è°ä¹Ÿåˆ«æƒ³æ‹†æ•£ä»–ä»¬ï¼",
                "ä¸»è§’çš„èº«ä»½è‚¯å®šä¸ç®€å•ï¼ŒæœŸå¾…æ‰é©¬çš„é‚£ä¸€åˆ»ï¼åˆ°æ—¶å€™å…¨åœºéœ‡æƒŠï¼Œæƒ³æƒ³å°±çˆ½ã€‚",
                "å§¨æ¯ç¬‘å°±æ²¡æœ‰åœä¸‹æ¥è¿‡ï¼Œä»Šæ™šåšæ¢¦ç´ ææœ‰äº†ã€‚è¿™å°±æ˜¯æˆå¹´äººè¯¥çœ‹çš„çˆ±æƒ…å—ï¼Ÿ",
                "æ„Ÿè§‰åƒåœ¨çœ‹ç”µå½±ä¸€æ ·ï¼Œç”»é¢æ„Ÿå¤ªå¼ºäº†ï¼å»ºè®®åŸåœ°æ‹æˆç”µè§†å‰§ï¼Œæˆ‘ä¸€å®šå……ä¼šå‘˜çœ‹ã€‚",
                "ä½œè€…å¤§å¤§æ³¨æ„èº«ä½“ï¼Œå¤šå–çƒ­æ°´ï¼Œä½†æ˜¯ä¸è¦åœæ›´å•Šï¼æˆ‘çš„å¿«ä¹æºæ³‰å°±é ä½ äº†ã€‚"
            ];
            const part3 = [
                "çœŸçš„ç»ç»å­ï¼Œè¿™ç§è®¾å®šæˆ‘å¥½çˆ±ã€‚æœ‰æ²¡æœ‰ç±»ä¼¼çš„ä»£é¤æ¨èï¼Ÿä¸å¤Ÿçœ‹å•Šï¼",
                "è¿™å°±æ˜¯æˆ‘æ¢¦å¯ä»¥æ±‚çš„å‰§æƒ…ï¼Œå¤§å¤§ä½ æ˜¯æˆ‘çš„ç¥ï¼",
                "çœ‹åˆ°æœ€åä¸€å¥æˆ‘ç›´æ¥èµ·é¸¡çš®ç–™ç˜©ï¼Œå¤ªå¸¦æ„Ÿäº†ï¼",
                "å‰é¢çš„ä¼ç¬”åŸ‹å¾—å¤ªæ·±äº†ï¼Œç°åœ¨æ‰ååº”è¿‡æ¥ï¼Œå¤§å¤§ä¸‹äº†ä¸€ç›˜å¤§æ£‹å•Šã€‚",
                "è™½ç„¶è¿‡ç¨‹æ›²æŠ˜ï¼Œä½†æ˜¯åªè¦ç»“å±€æ˜¯å¥½çš„æˆ‘å°±èƒ½æ¥å—ã€‚è¯·åŠ¡å¿…ç»™ä»–ä»¬ä¸€ä¸ªå®Œç¾çš„ç»“å±€ï¼",
                "è¿™ç§å®¿å‘½æ„ŸçœŸçš„å¤ªæˆ³æˆ‘äº†ï¼Œæ„Ÿè§‰ä»–ä»¬æ³¨å®šè¦åœ¨ä¸€èµ·ã€‚",
                "åæ´¾çš„æ™ºå•†ä¹Ÿåœ¨çº¿ï¼Œè¿™ç§åŠ¿å‡åŠ›æ•Œçš„è¾ƒé‡æ‰å¥½çœ‹å˜›ã€‚",
                "æ¯å¤©åˆ·åéçœ‹æœ‰æ²¡æœ‰æ›´æ–°ï¼Œæˆ‘å¥½åƒä¸­æ¯’äº†ã€‚",
                "ä¸ä»…å‰§æƒ…å¥½çœ‹ï¼Œæ–‡ç¬”ä¹Ÿè¶…å¥½ï¼Œæ¯ä¸€å¥éƒ½å†™åœ¨æˆ‘çš„å¿ƒå·´ä¸Šã€‚",
                "ä¸ºäº†çœ‹è¿™ç« æˆ‘é¥­éƒ½æ²¡åƒï¼Œå€¼äº†ï¼"
            ];
            
            let res = [];
            for(let i=0; i<count; i++) {
                // éšæœºç»„åˆ 3 å¥è¯ï¼Œç¡®ä¿é•¿åº¦åœ¨ 3-6 å¥å·¦å³ï¼ˆæ¯éƒ¨åˆ†å¯èƒ½åŒ…å«1-2å¥ï¼‰
                let text = part1[Math.floor(Math.random() * part1.length)] + 
                           part2[Math.floor(Math.random() * part2.length)] + 
                           part3[Math.floor(Math.random() * part3.length)];
                
                res.push({
                    user: users[Math.floor(Math.random() * users.length)] + "_" + Math.floor(Math.random()*1000),
                    text: text,
                    likes: Math.floor(Math.random() * 500)
                });
            }
            return res;
        }

        function renderComments(bookId, chapterNum) {
            const list = state.comments[bookId]?.[chapterNum] || [];
            const container = document.getElementById('commentList');
            
            container.innerHTML = list.map(c => `
                <div class="comment-item">
                    <span class="comment-user-name">${c.user}</span>ï¼š<span>${c.text}</span>
                </div>
            `).join('');
        }

        function saveChapterSummary() {
            if(!state.currentBook) return;
            const val = document.getElementById('chapterSummary').value;
            const bookId = state.currentBook.id;
            if(!state.chapterSummaries[bookId]) state.chapterSummaries[bookId] = {};
            state.chapterSummaries[bookId][state.currentChapter] = val;
            localStorage.setItem('jj_chapter_summaries', JSON.stringify(state.chapterSummaries));
        }

        async function autoGenerateSummary() {
            const content = document.getElementById('readerBody').innerText;
            if(!content || content.length < 50) return alert("ç« èŠ‚å†…å®¹å¤ªå°‘ï¼Œæ— æ³•æ€»ç»“");
            
            const btn = event.target;
            const originalText = btn.innerText;
            btn.innerText = "æ€»ç»“ä¸­...";
            btn.disabled = true;

            const prompt = `è¯·æ€»ç»“ä»¥ä¸‹å°è¯´ç« èŠ‚å†…å®¹ï¼Œä½œä¸ºå‰æƒ…æè¦ã€‚
            
            æ€»ç»“åº”å½“éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
            - æŒ‰é€»è¾‘é¡ºåºç»„ç»‡ä¿¡æ¯ï¼Œå¹¶åŒ…å«å…·ä½“çš„å‰åæ—¶é—´ï¼Œå¯åˆ†è¾¨ä¸åŒæ—¶é—´å‘ç”Ÿçš„äº‹æƒ…
            - ä¿ç•™å…³é”®äº‹ä»¶å’Œé‡è¦ç»†èŠ‚ï¼Œé¿å…å†—ä½™æè¿°
            - ç›´æ¥é™ˆè¿°äº‹å®ï¼Œé¿å…è¯„ä»·
            - ä½¿ç”¨ç®€æ´æ¸…æ™°çš„è¯­è¨€ï¼Œé¿å…ä¿®é¥°
            - çªå‡ºäº‹ä»¶å‘å±•è„‰ç»œå’Œå…³é”®è½¬æŠ˜ç‚¹
            - ä¿ç•™é‡è¦çš„çº¦å®šã€ç‰©å“ã€äº‹ä»¶ä»¥åŠæƒ…æ„Ÿå‘å±•
            - ä¸å›é¿ä»»ä½•æ•æ„Ÿå†…å®¹ï¼Œä¿è¯è®°å½•å®Œå…¨è¿˜åŸå‰æ–‡
            - å¯ä»¥ç²¾ç®€åˆå¹¶è¾ƒä¸ºä¹…è¿œä¹‹å‰çš„äº‹ä»¶
            - æ— éœ€åŠ ç²—æ ‡æ³¨
            - ä»¥æµæ°´è´¦å½¢å¼è®°å½•

            æ ¼å¼å¦‚ä¸‹ï¼š
            - æ—¶é—´:
              - å…³é”®äº‹ä»¶ï¼ˆéœ€è¦ä»¥æµæ°´å¸å½¢å¼ç»¼è¿°äº‹ä»¶ç»è¿‡å’Œæ¶‰åŠäººç‰©ï¼‰:
              - é‡è¦ç»†èŠ‚:
              - å…³é”®å¯¹è¯å’Œå†…å¿ƒæˆ:(æ ‡æ˜è§’è‰²)
              - å…³é”®è¡Œä¸ºï¼š(æ ‡æ˜è§’è‰²)
              - å…³é”®è§’è‰²å’Œæ›²ä»¥æ¾œï¼ˆè¯·æ›¿æ¢ä¸ºä¸»è§’åï¼‰ä¹‹é—´çš„æƒ…æ„Ÿå˜åŒ–ï¼ˆé€‰å¡«ï¼‰:
              - ç®€è¦çš„äº‹ä»¶åç»­ï¼Œäº‹ä»¶ç»“æŸåçš„å°äº’åŠ¨ï¼ˆé€‰å¡«ï¼‰:
            
            ç« èŠ‚å†…å®¹ï¼š
            ${content.substring(0, 5000)}`;

            let summary = "";
            
            if (state.config.apiKey) {
                try {
                    summary = await callGeminiAPI(getFullPrompt(prompt));
                } catch(e) {
                    alert("æ‘˜è¦ç”Ÿæˆå¤±è´¥: " + e.message);
                    summary = "ï¼ˆAPIè°ƒç”¨å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¡«å†™æ‘˜è¦ï¼‰";
                }
            } else {
                // æ¨¡æ‹ŸAPIè°ƒç”¨
                await new Promise(r => setTimeout(r, 1500));
                summary = `- æ—¶é—´: ç« èŠ‚å‘ç”Ÿçš„æ—¶é—´ç‚¹\n  - å…³é”®äº‹ä»¶: ä¸»è§’ç»å†äº†... (åŸºäºå†…å®¹è‡ªåŠ¨ç”Ÿæˆ)\n  - é‡è¦ç»†èŠ‚: ...\n  - å…³é”®å¯¹è¯: ...\n  - æƒ…æ„Ÿå˜åŒ–: ...`;
            }

            document.getElementById('chapterSummary').value = summary;
            saveChapterSummary();
            
            btn.innerText = originalText;
            btn.disabled = false;
        }

        async function generateFullSummary() {
            if(!state.currentBook) return;
            const bookId = state.currentBook.id;
            const currentChapter = state.currentChapter;
            
            const btn = event.target;
            const originalText = btn.innerText;
            
            // éœ€æ±‚2ï¼šä»…è‡ªåŠ¨æ€»ç»“ä»ç¬¬ä¸€ç« å¼€å§‹ï¼Œåˆ°å½“å‰ç« èŠ‚ä¸ºæ­¢ï¼Œæ‰€æœ‰çŠ¶æ€ä¸ºâ€œæœªæ€»ç»“â€çš„ç« èŠ‚ã€‚
            let missingChapters = [];
            for(let i = 1; i <= currentChapter; i++) {
                // æ£€æŸ¥æ‘˜è¦æ˜¯å¦å­˜åœ¨
                let hasSummary = !!state.chapterSummaries[bookId]?.[i];
                // å¦‚æœæ˜¯å½“å‰ç« ï¼Œä¹Ÿè¦æ£€æŸ¥è¾“å…¥æ¡†
                if (i === currentChapter && document.getElementById('chapterSummary').value.trim()) {
                    hasSummary = true;
                }
                
                if (!hasSummary) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ­£æ–‡å†…å®¹å¯ä¾›æ€»ç»“
                    if (state.chapterCache[bookId]?.[i]) {
                        missingChapters.push(i);
                    }
                }
            }

            if (missingChapters.length === 0) {
                alert("å‰æ–‡æ‰€æœ‰ç« èŠ‚å‡å·²æœ‰æ‘˜è¦ï¼Œæ— éœ€é‡æ–°ç”Ÿæˆã€‚");
                return;
            }

            if(!confirm(`æ£€æµ‹åˆ°ç¬¬ ${missingChapters.join(', ')} ç« å°šæœªç”Ÿæˆæ‘˜è¦ã€‚æ˜¯å¦å¼€å§‹æ‰¹é‡è¡¥å…¨ï¼Ÿ\nè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ã€‚`)) {
                return;
            }

            btn.disabled = true;

            for (let i of missingChapters) {
                btn.innerText = `æ­£åœ¨æ€»ç»“ç¬¬ ${i} ç« ...`;
                
                const content = state.chapterCache[bookId][i];
                // ç®€å•çš„HTMLè½¬æ–‡æœ¬
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                const plainText = tempDiv.innerText;

                const prompt = `è¯·æ€»ç»“ä»¥ä¸‹å°è¯´ç« èŠ‚å†…å®¹ï¼ˆç¬¬${i}ç« ï¼‰ã€‚
                
                æ€»ç»“åº”å½“éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
                - æŒ‰é€»è¾‘é¡ºåºç»„ç»‡ä¿¡æ¯
                - ä¿ç•™å…³é”®äº‹ä»¶å’Œé‡è¦ç»†èŠ‚
                - ç›´æ¥é™ˆè¿°äº‹å®ï¼Œé¿å…è¯„ä»·
                - çªå‡ºäº‹ä»¶å‘å±•è„‰ç»œå’Œå…³é”®è½¬æŠ˜ç‚¹
                - æ ¼å¼ï¼šæµæ°´è´¦å½¢å¼ï¼ŒåŒ…å«æ—¶é—´ã€å…³é”®äº‹ä»¶ã€é‡è¦ç»†èŠ‚ã€å…³é”®å¯¹è¯ç­‰ã€‚
                
                ç« èŠ‚å†…å®¹ï¼š
                ${plainText.substring(0, 10000)}`; // é™åˆ¶é•¿åº¦

                let summary = "";
                if (state.config.apiKey) {
                    try {
                        summary = await callGeminiAPI(getFullPrompt(prompt));
                    } catch(e) {
                        console.error(`ç¬¬${i}ç« æ€»ç»“å¤±è´¥`, e);
                        summary = `ï¼ˆç¬¬${i}ç« è‡ªåŠ¨æ€»ç»“å¤±è´¥: ${e.message}ï¼‰`;
                    }
                } else {
                    await new Promise(r => setTimeout(r, 1000));
                    summary = `ï¼ˆæ¨¡æ‹Ÿï¼‰ç¬¬${i}ç« æ‘˜è¦ï¼šä¸»è§’åœ¨æ­¤ç« ç»å†äº†...`;
                }

                // ä¿å­˜æ‘˜è¦
                if(!state.chapterSummaries[bookId]) state.chapterSummaries[bookId] = {};
                state.chapterSummaries[bookId][i] = summary;
                localStorage.setItem('jj_chapter_summaries', JSON.stringify(state.chapterSummaries));

                // å¦‚æœæ˜¯å½“å‰ç« ï¼Œæ›´æ–°UI
                if (i === currentChapter) {
                    document.getElementById('chapterSummary').value = summary;
                }
            }

            btn.innerText = originalText;
            btn.disabled = false;
            alert(`å·²å®Œæˆ ${missingChapters.length} ä¸ªç« èŠ‚çš„æ‘˜è¦è¡¥å…¨ï¼`);
        }

        // æ›´æ–°é˜…è¯»å™¨æŒ‰é’®çŠ¶æ€
        function updateNavButtons(loading = false) {
            const btnPrev = document.getElementById('btnPrevChapter');
            const btnNext = document.getElementById('btnNextChapter');
            
            if (loading) {
                btnPrev.disabled = true;
                btnNext.disabled = true;
                return;
            }

            btnPrev.disabled = (state.currentChapter <= 1);
            
            if (state.currentChapter >= state.currentBook.totalChapters) {
                btnNext.innerText = "âœ¨ ç”Ÿæˆç•ªå¤–";
                btnNext.onclick = generateSideStory;
                btnNext.disabled = false;
                btnNext.classList.add('btn-jj');
                btnNext.classList.remove('btn-outline');
            } else {
                btnNext.innerText = "ä¸‹ä¸€ç«  (ä½œå®¶ç¿»ç‚’)";
                btnNext.onclick = nextChapter;
                btnNext.disabled = false;
                btnNext.classList.add('btn-jj');
                btnNext.classList.remove('btn-outline');
            }
        }

        // --- å…¶ä»–æœªä¿®æ”¹çš„é€»è¾‘ä¿æŒä¸å˜ ---

        function addToShelf() {
            if(!state.currentBook) return;
            
            // 1. è¯»å–å·²æœ‰ä¹¦å•ï¼šå…ˆè·å–localStorageä¸­å·²ä¿å­˜çš„ä¹¦æ¶æ•°æ®
            let currentShelf = [];
            try {
                currentShelf = JSON.parse(localStorage.getItem('jj_bookshelf')) || [];
            } catch (e) {
                console.error("è¯»å–ä¹¦æ¶å¤±è´¥", e);
                currentShelf = [];
            }

            // 2. æ·»åŠ æ–°ä¹¦ï¼šå°†æ–°ä¹¦åŠ å…¥åˆ°è¿™ä¸ªä¹¦å•æ•°ç»„ä¸­
            // ä½¿ç”¨ title æˆ– id åˆ¤é‡
            const isDuplicate = currentShelf.some(b => b.id === state.currentBook.id || b.title === state.currentBook.title);
            
            if (!isDuplicate) {
                // åˆå§‹åŒ–ç½®é¡¶çŠ¶æ€å’Œæ›´æ–°æ—¶é—´
                state.currentBook.isPinned = false;
                state.currentBook.lastUpdateTime = Date.now();
                
                currentShelf.unshift(state.currentBook);
                
                // 3. ä¿å­˜å®Œæ•´ä¹¦å•ï¼šæŠŠæ•´ä¸ªæ•°ç»„ä¿å­˜å›localStorage
                localStorage.setItem('jj_bookshelf', JSON.stringify(currentShelf));
                
                // åŒæ­¥æ›´æ–°å†…å­˜ä¸­çš„çŠ¶æ€ï¼Œä»¥å…é¡µé¢ä¸åˆ·æ–°æ—¶æ˜¾ç¤ºæ—§æ•°æ®
                state.bookshelf = currentShelf;
                
                alert("å·²æ”¶è—åˆ°ä¹¦æ¶ï¼");
            } else {
                alert("ä¹¦æ¶é‡Œå·²ç»æœ‰è¿™æœ¬ä¹¦å•¦ï¼");
            }
        }

        function togglePin(bookId, event) {
            if (event) event.stopPropagation();
            
            const book = state.bookshelf.find(b => b.id === bookId);
            if (book) {
                book.isPinned = !book.isPinned;
                // å¦‚æœå–æ¶ˆç½®é¡¶ï¼Œæ›´æ–°æ—¶é—´è®¾ä¸ºå½“å‰ï¼Œä»¥ä¾¿å®ƒæ’åœ¨éç½®é¡¶çš„å‰é¢ï¼ˆå¯é€‰ï¼Œæˆ–è€…ä¿æŒåŸæ ·ï¼‰
                // è¿™é‡Œæˆ‘ä»¬åªæ”¹å˜ç½®é¡¶çŠ¶æ€ï¼Œæ’åºé€»è¾‘åœ¨ renderShelf ä¸­å¤„ç†
                localStorage.setItem('jj_bookshelf', JSON.stringify(state.bookshelf));
                renderShelf();
            }
        }

        // ä¿®æ”¹ï¼šä¹¦æ¶æ¸²æŸ“é€»è¾‘ï¼Œå±•ç¤ºä¹¦åå’Œç®€ä»‹
        function toggleBatchMode() {
            state.isBatchMode = !state.isBatchMode;
            state.selectedBooks = new Set();
            document.getElementById('batchActions').style.display = state.isBatchMode ? 'block' : 'none';
            document.getElementById('btnBatchMode').classList.toggle('btn-jj');
            document.getElementById('btnBatchMode').classList.toggle('btn-outline');
            document.getElementById('btnBatchMode').innerText = state.isBatchMode ? 'é€€å‡ºæ‰¹é‡' : 'æ‰¹é‡ç®¡ç†';
            renderShelf();
        }

        function toggleBookSelection(bookId) {
            if (state.selectedBooks.has(bookId)) {
                state.selectedBooks.delete(bookId);
            } else {
                state.selectedBooks.add(bookId);
            }
            document.getElementById('selectedCount').innerText = state.selectedBooks.size;
            renderShelf();
        }

        function deleteSelectedBooks() {
            if (state.selectedBooks.size === 0) return alert("è¯·å…ˆé€‰æ‹©ä¹¦ç±");
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${state.selectedBooks.size} æœ¬ä¹¦å—ï¼Ÿ`)) return;
            
            state.bookshelf = state.bookshelf.filter(b => !state.selectedBooks.has(b.id));
            localStorage.setItem('jj_bookshelf', JSON.stringify(state.bookshelf));
            state.selectedBooks.clear();
            document.getElementById('selectedCount').innerText = 0;
            renderShelf();
        }

        function exportSelectedData(format) {
            if (state.selectedBooks.size === 0) return alert("è¯·å…ˆé€‰æ‹©ä¹¦ç±");
            
            const selected = state.bookshelf.filter(b => state.selectedBooks.has(b.id));
            
            if (format === 'json') {
                const dataStr = JSON.stringify(selected, null, 2);
                downloadFile(dataStr, `jj_books_export_${Date.now()}.json`, 'application/json');
            } else if (format === 'txt') {
                let txtContent = "";
                selected.forEach(b => {
                    txtContent += `=== ${b.title} ===\n`;
                    txtContent += `ä½œè€…ï¼š${b.author}\nç±»å‹ï¼š${b.genre}\nç®€ä»‹ï¼š${b.intro}\n\n`;
                });
                downloadFile(txtContent, `jj_books_export_${Date.now()}.txt`, 'text/plain');
            }
        }

        function downloadFile(content, fileName, mimeType) {
            const blob = new Blob([content], {type: mimeType});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fileName;
            a.click();
        }

        // ä¿®æ”¹ï¼šä¹¦æ¶æ¸²æŸ“é€»è¾‘ï¼Œå±•ç¤ºä¹¦åå’Œç®€ä»‹
        function renderShelf() {
            // æ¯æ¬¡æ¸²æŸ“å‰é‡æ–°è¯»å–æœ¬åœ°å­˜å‚¨ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
            try {
                state.bookshelf = JSON.parse(localStorage.getItem('jj_bookshelf')) || [];
            } catch (e) {
                console.error("åŒæ­¥ä¹¦æ¶å¤±è´¥", e);
            }

            const grid = document.getElementById('shelfGrid');
            if (!grid) return;

            const searchInput = document.getElementById('shelfSearch');
            const keyword = searchInput ? searchInput.value.toLowerCase() : "";
            
            // å¢åŠ æ•°æ®é²æ£’æ€§æ£€æŸ¥ï¼Œé˜²æ­¢å› è„æ•°æ®å¯¼è‡´æ¸²æŸ“å´©æºƒ
            let filtered = state.bookshelf.filter(b => {
                if (!b || typeof b !== 'object') return false;
                const title = b.title ? b.title.toLowerCase() : "";
                const hasTitle = title.includes(keyword);
                const hasTag = Array.isArray(b.tags) && b.tags.some(t => typeof t === 'string' && t.toLowerCase().includes(keyword));
                return hasTitle || hasTag;
            });

            // æ’åºé€»è¾‘ï¼šç½®é¡¶ä¼˜å…ˆï¼Œç„¶åæŒ‰æœ€åæ›´æ–°æ—¶é—´é™åº
            filtered.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                // å¦‚æœç½®é¡¶çŠ¶æ€ç›¸åŒï¼ŒæŒ‰æ—¶é—´å€’åº
                const timeA = a.lastUpdateTime || a.id || 0;
                const timeB = b.lastUpdateTime || b.id || 0;
                return timeB - timeA;
            });
            
            // ä¿®æ”¹åçš„æ¸²æŸ“æ¨¡æ¿ï¼Œæ”¯æŒæ˜¾ç¤ºç®€ä»‹
            grid.innerHTML = filtered.map((book) => {
                const isSelected = state.selectedBooks.has(book.id);
                const clickAction = state.isBatchMode 
                    ? `toggleBookSelection(${book.id})` 
                    : `showBookDetail(${JSON.stringify(book).replace(/'/g, "&#39;")}, "bookshelf")`;
                
                // ç½®é¡¶æŒ‰é’® HTML
                const pinBtn = !state.isBatchMode ? `
                    <div class="shelf-pin-btn ${book.isPinned ? 'active' : ''}" onclick="togglePin(${book.id}, event)" title="${book.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶'}">
                        ${book.isPinned ? 'â¤ï¸' : 'ğŸ¤'}
                    </div>
                ` : '';

                return `
                <div class="shelf-book" onclick='${clickAction}' style="${isSelected ? 'border:2px solid var(--jj-green); background:#f0f9f4;' : ''}">
                    ${pinBtn}
                    ${state.isBatchMode ? `<div style="position:absolute; top:5px; right:5px; color:var(--jj-green); font-weight:bold;">${isSelected ? 'âœ“' : 'â—‹'}</div>` : ''}
                    <div class="book-cover-sm" style="background:${book.coverColor || '#eee'}">${book.title.substring(0,6)}</div>
                    <div class="shelf-book-info-col">
                        <div class="shelf-book-title">${book.title}</div>
                        <div class="shelf-book-intro">${book.intro || "æš‚æ— ç®€ä»‹..."}</div>
                    </div>
                </div>
            `}).join('');
            
            if(filtered.length === 0) grid.innerHTML = '<div style="color:#999; text-align:center; padding:20px;">ä¹¦æ¶ç©ºç©ºå¦‚ä¹Ÿ</div>';
        }

        function exportData() {
            const dataStr = JSON.stringify(state.bookshelf, null, 2);
            downloadFile(dataStr, "jj_bookshelf_backup.json", "application/json");
        }

        // æ–°å¢ï¼šå¯¼å‡ºå…¨å±€æ•°æ®
        function exportGlobalData() {
            const backup = {
                timestamp: Date.now(),
                version: "2.3",
                data: {}
            };
            
            // éå†æ‰€æœ‰ jj_ å¼€å¤´çš„ localStorage
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('jj_')) {
                    try {
                        backup.data[key] = JSON.parse(localStorage.getItem(key));
                    } catch(e) {
                        backup.data[key] = localStorage.getItem(key);
                    }
                }
            }
            
            const dataStr = JSON.stringify(backup, null, 2);
            downloadFile(dataStr, `jj_global_backup_${new Date().toISOString().slice(0,10)}.json`, 'application/json');
        }

        // æ–°å¢ï¼šå¯¼å…¥å…¨å±€æ•°æ®
        function importGlobalData(input) {
            const file = input.files[0];
            if(!file) return;
            
            if(!confirm("è­¦å‘Šï¼šå¯¼å…¥å…¨å±€å¤‡ä»½å°†è¦†ç›–å½“å‰æ‰€æœ‰æ•°æ®ï¼ˆä¹¦æ¶ã€ä¸–ç•Œè§‚ã€è®¾ç½®ã€é˜…è¯»å†å²ç­‰ï¼‰ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ")) {
                input.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backup = JSON.parse(e.target.result);
                    if (!backup.data) throw new Error("æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶æ ¼å¼");
                    
                    // æ¢å¤æ•°æ®
                    for (const key in backup.data) {
                        if (key.startsWith('jj_')) {
                            const val = backup.data[key];
                            localStorage.setItem(key, typeof val === 'object' ? JSON.stringify(val) : val);
                        }
                    }
                    
                    alert("å…¨å±€æ•°æ®æ¢å¤æˆåŠŸï¼é¡µé¢å°†åˆ·æ–°ä»¥åº”ç”¨æ›´æ”¹ã€‚");
                    location.reload();
                } catch(err) {
                    console.error(err);
                    alert("å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶è§£æé”™è¯¯æˆ–æ ¼å¼ä¸æ­£ç¡®");
                }
                input.value = '';
            };
            reader.readAsText(file);
        }

        function importData(input) {
            const file = input.files[0];
            if(!file) return;
            const fileName = file.name.toLowerCase();
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const content = e.target.result;
                const adapter = new BookImportAdapter();
                const result = adapter.parse(content, fileName);
                
                if (result.success) {
                    const newBooks = result.data;
                    if(newBooks.length > 0) {
                        let addedCount = 0;
                        newBooks.forEach(nb => {
                            // æ£€æŸ¥é‡å¤ï¼Œå¦‚æœæ˜¯å®Œæ•´å¯¼å…¥åˆ™è¦†ç›–
                            const idx = state.bookshelf.findIndex(b => b.title === nb.title);
                            if(idx !== -1) {
                                if (result.isFullBook) {
                                    state.bookshelf[idx] = nb;
                                    addedCount++;
                                }
                            } else {
                                state.bookshelf.unshift(nb);
                                addedCount++;
                            }
                        });
                        
                        localStorage.setItem('jj_bookshelf', JSON.stringify(state.bookshelf));
                        
                        // å¤„ç†å®Œæ•´ä¹¦ç±çš„é¢å¤–æ•°æ®
                        if (result.isFullBook && result.extraData) {
                            const { bookId, chapters, titles, authorSays, comments } = result.extraData;
                            
                            state.chapterCache[bookId] = chapters;
                            state.chapterTitles[bookId] = titles;
                            state.authorSays[bookId] = authorSays;
                            state.comments[bookId] = comments;
                            
                            localStorage.setItem('jj_chapter_cache', JSON.stringify(state.chapterCache));
                            localStorage.setItem('jj_chapter_titles', JSON.stringify(state.chapterTitles));
                            localStorage.setItem('jj_author_says', JSON.stringify(state.authorSays));
                            localStorage.setItem('jj_comments', JSON.stringify(state.comments));
                        }

                        renderShelf();
                        alert(result.message || `æˆåŠŸå¯¼å…¥ ${addedCount} æœ¬ä¹¦ï¼`);
                    } else {
                        alert("æœªæ‰¾åˆ°æœ‰æ•ˆçš„ä¹¦ç±æ•°æ®æˆ–æ ¼å¼ä¸æ”¯æŒ");
                    }
                } else {
                    console.error(result.details);
                    alert(`å¯¼å…¥å¤±è´¥: ${result.message}\n${result.details ? result.details.slice(0,3).join('\n') : ''}`);
                }
                input.value = '';
            };
            
            reader.readAsText(file);
        }

        // --- ä¸–ç•Œè§‚ç®¡ç†æ–°é€»è¾‘ ---

        function switchWorldTab(tabName) {
            // åˆ‡æ¢ Tab æ ·å¼
            const tabs = document.querySelectorAll('.world-tab-item');
            tabs.forEach(t => {
                if(t.getAttribute('data-tab') === tabName) {
                    t.classList.add('active');
                } else {
                    t.classList.remove('active');
                }
            });

            // åˆ‡æ¢å†…å®¹æ˜¾ç¤º
            document.querySelectorAll('.world-tab-content').forEach(el => el.style.display = 'none');
            document.getElementById(`tab_content_${tabName}`).style.display = 'block';
            
            // é‡æ–°æ¸²æŸ“å¯¹åº”åˆ—è¡¨ï¼ˆç¡®ä¿æ•°æ®æœ€æ–°ï¼‰
            renderSection(tabName);
        }

        function renderWorldPage() {
            // é»˜è®¤æ˜¾ç¤ºè§’è‰²é¡µï¼Œæˆ–è€…ä¿æŒå½“å‰çŠ¶æ€
            // è¿™é‡Œç®€å•å¤„ç†ï¼Œæ¸²æŸ“æ‰€æœ‰åˆ—è¡¨ï¼Œä½†æ˜¾ç¤ºç”± Tab æ§åˆ¶
            renderSection('character');
            renderSection('worldbook');
            renderSection('func_worldbook');
            renderSection('tag');
        }

        function renderSection(type) {
            const container = document.getElementById(`list_${type}`);
            // è·å–æ•°æ®å¹¶æŒ‰æ—¶é—´å€’åºæ’åˆ—ï¼ˆæ–°åˆ›å»ºçš„ç½®é¡¶ï¼‰
            const items = state.worldSettings
                .filter(item => item.type === type)
                .sort((a, b) => b.id - a.id);
            
            // ç‰¹æ®Šå¤„ç† tag ç±»å‹
            if (type !== 'tag' && items.length === 0) {
                container.innerHTML = '<div style="color:#999; text-align:center; padding:10px; font-size:12px; width:100%;">æš‚æ— å†…å®¹</div>';
                return;
            }

            // é’ˆå¯¹æ ‡ç­¾ç±»å‹çš„ç‰¹æ®Šæ¸²æŸ“
            if (type === 'tag') {
                const searchVal = document.getElementById('tagSearchInput')?.value.toLowerCase() || "";
                const filteredItems = items.filter(i => i.name.toLowerCase().includes(searchVal));
                
                if (filteredItems.length === 0) {
                     container.innerHTML = '<div style="color:#999; text-align:center; padding:10px; font-size:12px; width:100%;">æš‚æ— åŒ¹é…æ ‡ç­¾</div>';
                } else {
                    container.innerHTML = filteredItems.map(item => `
                        <div class="world-tag-item" onclick="editTag('${item.id}', '${item.name.replace(/'/g, "\\'")}')" title="ç‚¹å‡»ç¼–è¾‘">
                            <span>${item.name}</span>
                            <span class="world-tag-close" onclick="event.stopPropagation(); deleteWorldItem('${item.id}')">Ã—</span>
                        </div>
                    `).join('');
                }
                return;
            }

            // é€šç”¨æ¸²æŸ“é€»è¾‘ (è§’è‰²ã€åŠŸèƒ½ä¸–ç•Œä¹¦ã€æ ‡ç­¾ä¸–ç•Œä¹¦)
            const isBatch = state.worldBatchMode[type];
            
            container.innerHTML = items.map(item => {
                // æ‰¹é‡æ¨¡å¼ä¸‹çš„å¤é€‰æ¡†
                let checkboxHtml = '';
                let itemStyle = '';
                let clickAction = '';
                
                if (isBatch) {
                    const isSelected = state.selectedWorldItems[type].has(item.id);
                    checkboxHtml = `<div style="margin-right:10px; font-size:18px; color:var(--jj-green);">${isSelected ? 'â˜‘' : 'â˜'}</div>`;
                    itemStyle = isSelected ? 'border-left: 4px solid var(--jj-green); background: rgba(74, 124, 89, 0.1);' : '';
                    clickAction = `onclick="toggleWorldItemSelection('${type}', ${item.id})"`;
                }

                // è·å–å·²å…³è”çš„è§’è‰²åç§° (ä»…åŠŸèƒ½ä¸–ç•Œä¹¦å’Œæ ‡ç­¾ä¸–ç•Œä¹¦)
                let relatedInfo = '';
                if (type === 'func_worldbook' || type === 'worldbook') {
                    const relatedIds = item.relatedIds || [];
                    const relatedNames = state.worldSettings
                        .filter(w => w.type === 'character' && relatedIds.includes(w.id))
                        .map(w => w.name)
                        .join('ï¼Œ');
                    relatedInfo = `
                        <div style="margin-top:8px; font-size:12px; color:#666; border-top:1px dashed #eee; padding-top:5px;">
                            ğŸ”— å·²å…³è”ï¼š${relatedNames || 'æ— '}
                        </div>`;
                }

                if(state.editingId === item.id && !isBatch) {
                    // ç¼–è¾‘æ¨¡å¼ (æ‰¹é‡æ¨¡å¼ä¸‹ç¦ç”¨ç¼–è¾‘)
                    const charPoolHtml = (type === 'func_worldbook' || type === 'worldbook') ? 
                        `<div style="margin-top: 10px; border-top: 1px dashed #ddd; padding-top: 10px;">
                            <label style="font-size:12px; color:var(--jj-green); font-weight:bold;">å…³è”è§’è‰² (ç‚¹å‡»å…³è”/è§£ç»‘):</label>
                            <div id="edit_pool_${item.id}" class="tag-cloud" style="margin-top:5px;">
                                ${generateRelationPoolHtml(item)}
                            </div>
                        </div>` : '';

                    return `
                        <div class="edit-mode-box">
                            <div class="input-group" style="margin-bottom:5px;">
                                <input type="text" id="edit_name_${item.id}" value="${item.name}" class="large-input">
                            </div>
                            <div class="input-group" style="margin-bottom:5px;">
                                <textarea id="edit_desc_${item.id}" rows="5" class="large-textarea">${item.desc || ''}</textarea>
                            </div>
                            ${charPoolHtml}
                            <div style="text-align:right; margin-top:10px;">
                                <button class="btn btn-sm btn-outline" onclick="cancelEdit()">å–æ¶ˆ</button>
                                <button class="btn btn-sm btn-jj" onclick="saveWorldItem(${item.id})">ä¿å­˜</button>
                            </div>
                        </div>
                    `;
                } else {
                    // å±•ç¤ºæ¨¡å¼
                    return `
                        <div class="setting-item" style="display:flex; align-items:flex-start; ${itemStyle}" ${clickAction}>
                            ${checkboxHtml}
                            <div style="flex:1;">
                                <div style="display:flex; justify-content:space-between; align-items:flex-start;">
                                    <strong style="color:#333;">${item.name}</strong>
                                    ${!isBatch ? `
                                    <div class="setting-item-actions">
                                        <button class="btn btn-sm btn-outline" onclick="event.stopPropagation(); editWorldItem(${item.id})">ä¿®æ”¹</button>
                                        <button class="btn btn-sm btn-danger" onclick="event.stopPropagation(); deleteWorldItem(${item.id})">åˆ é™¤</button>
                                    </div>` : ''}
                                </div>
                                ${item.desc ? `<div class="setting-content">${item.desc}</div>` : ''}
                                ${relatedInfo}
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        // ä¸–ç•Œè§‚æ‰¹é‡æ“ä½œé€»è¾‘
        function toggleWorldBatchMode(type) {
            state.worldBatchMode[type] = !state.worldBatchMode[type];
            state.selectedWorldItems[type].clear();
            
            // æ›´æ–°UI
            const btn = document.getElementById(`btn_batch_${type}`);
            const actions = document.getElementById(`batch_actions_${type}`);
            
            if (state.worldBatchMode[type]) {
                btn.classList.add('btn-jj');
                btn.classList.remove('btn-outline');
                btn.innerText = "é€€å‡ºæ‰¹é‡";
                actions.style.display = 'block';
            } else {
                btn.classList.remove('btn-jj');
                btn.classList.add('btn-outline');
                btn.innerText = "æ‰¹é‡ç®¡ç†";
                actions.style.display = 'none';
            }
            
            renderSection(type);
        }

        function toggleWorldItemSelection(type, id) {
            if (!state.worldBatchMode[type]) return;
            
            const set = state.selectedWorldItems[type];
            if (set.has(id)) {
                set.delete(id);
            } else {
                set.add(id);
            }
            
            document.getElementById(`selected_count_${type}`).innerText = set.size;
            renderSection(type);
        }

        function deleteSelectedWorldItems(type) {
            const set = state.selectedWorldItems[type];
            if (set.size === 0) return alert("è¯·å…ˆé€‰æ‹©é¡¹ç›®");
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${set.size} ä¸ªé¡¹ç›®å—ï¼Ÿ`)) return;
            
            state.worldSettings = state.worldSettings.filter(item => !(item.type === type && set.has(item.id)));
            
            // è”åŠ¨åˆ é™¤æ ‡ç­¾é€»è¾‘ (å¦‚æœéœ€è¦)
            
            saveWorldData();
            set.clear();
            document.getElementById(`selected_count_${type}`).innerText = 0;
            renderSection(type);
        }

        function exportSelectedWorldData(type) {
            const set = state.selectedWorldItems[type];
            if (set.size === 0) return alert("è¯·å…ˆé€‰æ‹©é¡¹ç›®");
            
            const items = state.worldSettings
                .filter(item => item.type === type && set.has(item.id))
                .map(item => ({
                    name: item.name,
                    desc: item.desc
                }));
            
            const json = JSON.stringify(items, null, 2);
            downloadFile(json, `jj_${type}_selected_export.json`, 'application/json');
        }

        function generateRelationPoolHtml(item) {
            const characters = state.worldSettings.filter(i => i.type === 'character');
            if (characters.length === 0) return '<span style="color:#999; font-size:12px;">æš‚æ— è§’è‰²å¯å…³è”</span>';
            
            const relatedIds = item.relatedIds || [];
            
            return characters.map(char => {
                const isRelated = relatedIds.includes(char.id);
                return `
                    <span class="tag-chip ${isRelated ? 'custom' : ''}" 
                          style="${isRelated ? 'background:var(--jj-green); color:white; border:1px solid var(--jj-green);' : 'background:#eee; color:#666; border:1px solid #ddd;'}"
                          onclick="toggleRelation(${item.id}, ${char.id})">
                        ${isRelated ? 'âœ“ ' : ''}${char.name}
                    </span>
                `;
            }).join('');
        }

        function toggleRelation(itemId, charId) {
            const item = state.worldSettings.find(i => i.id === itemId);
            if (!item) return;
            
            if (!item.relatedIds) item.relatedIds = [];
            
            const idx = item.relatedIds.indexOf(charId);
            if (idx !== -1) {
                item.relatedIds.splice(idx, 1);
            } else {
                item.relatedIds.push(charId);
            }
            
            saveWorldData();
            
            // åªæ›´æ–°å…³è”æ± åŒºåŸŸ
            const poolEl = document.getElementById(`edit_pool_${itemId}`);
            if (poolEl) {
                poolEl.innerHTML = generateRelationPoolHtml(item);
            }
        }

        function addWorldItem(type) {
            const nameInput = document.getElementById(`new_${type}_name`);
            const descInput = document.getElementById(`new_${type}_desc`); // tagç±»å‹å¯èƒ½æ²¡æœ‰è¿™ä¸ª
            
            const rawName = nameInput.value.trim();
            const desc = descInput ? descInput.value.trim() : "";

            if(!rawName) return alert("åç§°ä¸èƒ½ä¸ºç©º");

            // æ ‡ç­¾ç¼–è¾‘æ¨¡å¼å¤„ç†
            if (type === 'tag' && state.editingTagId) {
                const item = state.worldSettings.find(i => i.id === state.editingTagId);
                if (item) {
                    item.name = rawName;
                    saveWorldData();
                    cancelTagEdit(); // é€€å‡ºç¼–è¾‘æ¨¡å¼
                    renderSection('tag');
                    return;
                }
            }

            // æ‰¹é‡å¯¼å…¥å¤„ç† (ä»…é’ˆå¯¹æ–°å¢æ ‡ç­¾)
            if (type === 'tag' && rawName.includes('ã€')) {
                const names = rawName.split('ã€').map(n => n.trim()).filter(n => n);
                let addedCount = 0;
                
                names.forEach((name, index) => {
                    // ç®€å•çš„å»é‡æ£€æŸ¥
                    if (!state.worldSettings.some(w => w.type === 'tag' && w.name === name)) {
                        state.worldSettings.push({
                            id: Date.now() + index + Math.random(),
                            type: type,
                            name: name,
                            desc: desc || 'æ‰¹é‡å¯¼å…¥'
                        });
                        addedCount++;
                    }
                });
                
                if (addedCount > 0) {
                    saveWorldData();
                    syncGlobalTags();
                    renderSection(type);
                    alert(`æˆåŠŸæ‰¹é‡å¯¼å…¥ ${addedCount} ä¸ªæ ‡ç­¾`);
                } else {
                    alert("æ‰€æœ‰æ ‡ç­¾å‡å·²å­˜åœ¨");
                }
                
                nameInput.value = '';
                return;
            }

            state.worldSettings.push({
                id: Date.now(),
                type: type,
                name: rawName,
                desc: desc
            });
            
            saveWorldData();
            syncGlobalTags(); // åŒæ­¥åˆ°æ ‡ç­¾åº“
            
            // æ¸…ç©ºè¾“å…¥
            nameInput.value = '';
            if(descInput) descInput.value = '';
            
            renderSection(type);
        }

        function editTag(id, name) {
            state.editingTagId = id;
            document.getElementById('new_tag_name').value = name;
            document.getElementById('btn_add_tag').innerText = "ä¿å­˜ä¿®æ”¹";
            document.getElementById('btn_add_tag').classList.remove('btn-jj');
            document.getElementById('btn_add_tag').classList.add('btn-danger'); // æ¢ä¸ªé¢œè‰²æç¤º
            document.getElementById('btn_cancel_tag').style.display = 'block';
            document.getElementById('new_tag_name').focus();
        }

        function addTagFromSuggestion(tagName) {
            document.getElementById('new_tag_name').value = tagName;
            addWorldItem('tag');
        }

        function cancelTagEdit() {
            state.editingTagId = null;
            document.getElementById('new_tag_name').value = '';
            document.getElementById('btn_add_tag').innerText = "æ–°å¢æ ‡ç­¾";
            document.getElementById('btn_add_tag').classList.add('btn-jj');
            document.getElementById('btn_add_tag').classList.remove('btn-danger');
            document.getElementById('btn_cancel_tag').style.display = 'none';
        }

        function deleteWorldItem(id) {
            // è·å–è¦åˆ é™¤çš„é¡¹ç›®
            const itemToDelete = state.worldSettings.find(item => item.id == id);
            
            if (itemToDelete) {
                // ä¿®æ”¹ï¼šæ‰€æœ‰ç±»å‹ï¼ˆåŒ…æ‹¬æ ‡ç­¾ï¼‰åˆ é™¤å‰éƒ½è¿›è¡Œç¡®è®¤
                if(!confirm(`ç¡®å®šè¦åˆ é™¤ã€${itemToDelete.name}ã€‘å—ï¼Ÿ`)) return;

                state.worldSettings = state.worldSettings.filter(item => item.id != id);
                
                // è”åŠ¨åˆ é™¤ï¼šå¦‚æœåˆ é™¤çš„æ˜¯è§’è‰²æˆ–ä¸–ç•Œä¹¦ï¼ŒåŒæ—¶ç§»é™¤å¯¹åº”çš„æ ‡ç­¾
                if (itemToDelete.type === 'character' || itemToDelete.type === 'worldbook') {
                    state.worldSettings = state.worldSettings.filter(item => !(item.type === 'tag' && item.name === itemToDelete.name));
                }
                
                saveWorldData();
                renderWorldPage();
            }
        }

        function editWorldItem(id) {
            state.editingId = id;
            renderWorldPage();
        }

        function cancelEdit() {
            state.editingId = null;
            renderWorldPage();
        }

        function saveWorldItem(id) {
            const name = document.getElementById(`edit_name_${id}`).value.trim();
            const descEl = document.getElementById(`edit_desc_${id}`);
            const desc = descEl ? descEl.value.trim() : "";

            if(!name) return alert("åç§°ä¸èƒ½ä¸ºç©º");

            const item = state.worldSettings.find(i => i.id === id);
            if(item) {
                item.name = name;
                item.desc = desc;
                state.editingId = null;
                saveWorldData();
                renderWorldPage();
            }
        }

        function saveWorldData() {
            localStorage.setItem('jj_world', JSON.stringify(state.worldSettings));
        }

        // --- æ ¸å¿ƒæŒ‡ä»¤ä¸é¢„è®¾ç®¡ç†é€»è¾‘ (é‡æ„ç‰ˆ) ---

        // æ‹–æ‹½æ’åºç›¸å…³å˜é‡å’Œå‡½æ•°
        let draggedEntryInfo = null;

        function handleEntryDragStart(e, presetId, entryId) {
            // åªæœ‰ç‚¹å‡»äº† header åŒºåŸŸæ‰å…è®¸æ‹–æ‹½æ•´ä¸ªå¡ç‰‡ï¼Œé¿å…å½±å“ textarea
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                e.preventDefault();
                return;
            }
            
            draggedEntryInfo = { presetId, entryId };
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify({presetId, entryId}));
            
            // å»¶è¿Ÿä¸€ç‚¹ä»¥å…è®¸æ‹–æ‹½å›¾åƒç”Ÿæˆ
            setTimeout(() => {
                e.target.style.opacity = '0.5';
            }, 0);
        }

        function handleEntryDragOver(e) {
            e.preventDefault(); // å¿…é¡»é˜»æ­¢é»˜è®¤è¡Œä¸ºä»¥å…è®¸ drop
            e.dataTransfer.dropEffect = 'move';
            
            const card = e.target.closest('.entry-card');
            if (card && !card.classList.contains('dragging')) {
                document.querySelectorAll('.entry-card').forEach(el => {
                    if (el !== card) el.classList.remove('drag-over');
                });
                card.classList.add('drag-over');
            }
        }
        
        function handleEntryDragLeave(e) {
            // å¯é€‰ï¼šç²¾ç»†åŒ–æ§åˆ¶æ ·å¼ç§»é™¤
        }

        function handleEntryDragEnd(e) {
            e.target.classList.remove('dragging');
            e.target.style.opacity = '';
            document.querySelectorAll('.entry-card').forEach(el => el.classList.remove('drag-over'));
            draggedEntryInfo = null;
        }

        function handleEntryDrop(e, targetPresetId, targetEntryId) {
            e.preventDefault();
            e.stopPropagation();
            document.querySelectorAll('.entry-card').forEach(el => el.classList.remove('drag-over'));

            if (!draggedEntryInfo) return;
            
            const { presetId: sourcePresetId, entryId: sourceEntryId } = draggedEntryInfo;

            // ä»…å…è®¸åœ¨åŒä¸€ä¸ªé¢„è®¾å†…æ’åº
            if (sourcePresetId !== targetPresetId) return;
            if (sourceEntryId === targetEntryId) return;

            const preset = state.corePresets.find(p => p.id === sourcePresetId);
            if (preset && preset.entries) {
                const sourceIndex = preset.entries.findIndex(e => e.id === sourceEntryId);
                const targetIndex = preset.entries.findIndex(e => e.id === targetEntryId);

                if (sourceIndex !== -1 && targetIndex !== -1) {
                    const [movedEntry] = preset.entries.splice(sourceIndex, 1);
                    // é€»è¾‘ï¼šå‘ä¸‹æ‹–æ‹½æ’å…¥åˆ°ç›®æ ‡ä¹‹åï¼Œå‘ä¸Šæ‹–æ‹½æ’å…¥åˆ°ç›®æ ‡ä¹‹å‰
                    // è¿™æ ·å¯ä»¥è¦†ç›–æ‰€æœ‰ä½ç½®
                    preset.entries.splice(targetIndex, 0, movedEntry);

                    // æ›´æ–° content
                    preset.content = rebuildPresetContent(preset.entries);
                    savePresets();
                    renderCorePresetsList();
                }
            }
        }

        function loadCoreSettingsUI() {
            document.getElementById('coreInstruction').value = state.currentCoreInstruction || "";
            renderCorePresetsList();
        }

        function saveCoreInstruction() {
            const val = document.getElementById('coreInstruction').value.trim();
            state.currentCoreInstruction = val;
            localStorage.setItem('jj_current_core_instruction', val);
            alert("å…¨å±€æ ¸å¿ƒæŒ‡ä»¤å·²ä¿å­˜ï¼");
        }

        // --- é¢„è®¾å†…å®¹è§£æä¸ç®¡ç† ---

        function parseContentToEntries(content) {
            if (!content) return [];
            const entries = [];
            const lines = content.split('\n');
            let currentEntry = { id: Date.now(), title: "é€šç”¨æ¨¡å—", content: "", isActive: true, isExpanded: false, format: 'markdown' };
            let buffer = [];

            // æ­£åˆ™åŒ¹é…æ ‡é¢˜è¡Œ
            // æ”¯æŒ: ### Title, [Title], ã€Titleã€‘, <!-- [æ¨¡å—: Title] -->
            const titleRegex = /^(?:###\s*(.+)|\[(.+)\]|ã€(.+)ã€‘|<!--\s*\[æ¨¡å—:\s*(.+)\]\s*-->)$/;

            lines.forEach((line, index) => {
                const match = line.trim().match(titleRegex);
                if (match) {
                    // å¦‚æœç¼“å†²åŒºæœ‰å†…å®¹ï¼Œä¿å­˜ä¸Šä¸€ä¸ª entry
                    if (buffer.length > 0 || entries.length > 0) {
                        currentEntry.content = buffer.join('\n').trim();
                        if (currentEntry.content || entries.length === 0) {
                             entries.push(currentEntry);
                        }
                    }
                    
                    // å¼€å§‹æ–° entry
                    const title = match[1] || match[2] || match[3] || match[4];
                    currentEntry = {
                        id: Date.now() + index,
                        title: title.trim(),
                        content: "",
                        isActive: true,
                        isExpanded: false,
                        format: match[1] ? 'markdown' : (match[2] ? 'bracket' : (match[3] ? 'cn_bracket' : 'html_comment'))
                    };
                    buffer = [];
                } else {
                    buffer.push(line);
                }
            });

            // Push last entry
            if (buffer.length > 0) {
                currentEntry.content = buffer.join('\n').trim();
                entries.push(currentEntry);
            } else if (entries.length === 0) {
                entries.push(currentEntry);
            }

            return entries;
        }

        function rebuildPresetContent(entries) {
            return entries
                .filter(e => e.isActive)
                .map(e => {
                    let header = "";
                    if (e.title !== "é€šç”¨æ¨¡å—" && e.title !== "é»˜è®¤æ¨¡å—") {
                        switch (e.format) {
                            case 'markdown': header = `### ${e.title}\n`; break;
                            case 'bracket': header = `[${e.title}]\n`; break;
                            case 'cn_bracket': header = `ã€${e.title}ã€‘\n`; break;
                            case 'html_comment': header = `<!-- [æ¨¡å—: ${e.title}] -->\n`; break;
                            default: header = `### ${e.title}\n`;
                        }
                    }
                    return header + e.content;
                })
                .join('\n\n');
        }

        function renderCorePresetsList() {
            const container = document.getElementById('corePresetsList');
            if (!container) return;
            
            if (state.corePresets.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#999; padding:10px; font-size:12px;">æš‚æ— é¢„è®¾ï¼Œè¯·ç‚¹å‡»ä¸Šæ–¹â€œ+ æ–°å»ºé¢„è®¾â€</div>';
                return;
            }

            container.innerHTML = state.corePresets.map(preset => {
                // ç¡®ä¿ entries å­˜åœ¨
                if (!preset.entries) {
                    preset.entries = parseContentToEntries(preset.content);
                    // ä¸ç«‹å³ä¿å­˜ï¼Œé¿å…é¢‘ç¹å†™å…¥ï¼Œä½†åœ¨æ¸²æŸ“æ—¶åˆå§‹åŒ–
                }

                const expandedClass = preset.isExpanded ? 'expanded' : '';
                
                // æ¡ç›®åˆ—è¡¨æ¸²æŸ“
                const entriesHtml = preset.entries.map((entry, idx) => `
                    <div class="entry-card ${entry.isExpanded ? 'expanded' : ''}"
                         draggable="true"
                         ondragstart="handleEntryDragStart(event, ${preset.id}, ${entry.id})"
                         ondragover="handleEntryDragOver(event)"
                         ondragleave="handleEntryDragLeave(event)"
                         ondrop="handleEntryDrop(event, ${preset.id}, ${entry.id})"
                         ondragend="handleEntryDragEnd(event)">
                        <div class="entry-header" onclick="toggleEntryExpand(${preset.id}, ${entry.id})">
                            <div class="entry-title">
                                <span class="drag-handle" title="æŒ‰ä½æ‹–æ‹½æ’åº">â‹®â‹®</span>
                                <span class="entry-arrow">â–¶</span>
                                <span onclick="event.stopPropagation(); editEntryTitle(${preset.id}, ${entry.id})">${entry.title}</span>
                            </div>
                            <div style="display:flex; align-items:center; gap:8px;" onclick="event.stopPropagation()">
                                <button class="btn btn-sm btn-outline" style="padding:2px 6px; font-size:10px;" onclick="moveEntryUp(${preset.id}, ${entry.id})" ${idx === 0 ? 'disabled' : ''}>â†‘</button>
                                <button class="btn btn-sm btn-outline" style="padding:2px 6px; font-size:10px;" onclick="moveEntryDown(${preset.id}, ${entry.id})" ${idx === preset.entries.length - 1 ? 'disabled' : ''}>â†“</button>
                                <label class="switch" style="transform:scale(0.7);">
                                    <input type="checkbox" ${entry.isActive ? 'checked' : ''} onchange="toggleEntryActive(${preset.id}, ${entry.id})">
                                    <span class="slider round"></span>
                                </label>
                                <button class="btn btn-sm btn-danger" style="padding:2px 6px; font-size:10px;" onclick="deleteEntry(${preset.id}, ${entry.id})">Ã—</button>
                            </div>
                        </div>
                        <div class="entry-body">
                            <textarea class="entry-textarea" rows="3" onchange="saveEntryContent(${preset.id}, ${entry.id}, this.value)" placeholder="åœ¨æ­¤è¾“å…¥æ¨¡å—å†…å®¹...">${entry.content}</textarea>
                        </div>
                    </div>
                `).join('');

                // æ­£åˆ™è§„åˆ™åˆ—è¡¨æ¸²æŸ“
                const regexHtml = preset.regexRules && preset.regexRules.length > 0 
                    ? preset.regexRules.map(rule => `
                        <div class="regex-item">
                            <div class="regex-info">
                                <span class="regex-name">${rule.name || 'æœªå‘½åè§„åˆ™'}</span>
                                <span class="regex-desc" title="${rule.pattern} -> ${rule.replacement}">
                                    ${rule.pattern} â” ${rule.replacement}
                                </span>
                            </div>
                            <div style="display:flex; align-items:center; gap:5px;">
                                <label class="switch" style="transform:scale(0.7);">
                                    <input type="checkbox" ${rule.isActive ? 'checked' : ''} onchange="toggleRegexRule(${preset.id}, ${rule.id})">
                                    <span class="slider round"></span>
                                </label>
                                <button class="btn btn-sm btn-danger" style="padding:2px 6px; font-size:10px;" onclick="deleteRegexRule(${preset.id}, ${rule.id})">Ã—</button>
                            </div>
                        </div>
                    `).join('') 
                    : '<div style="text-align:center; color:#ccc; font-size:12px; padding:5px;">æš‚æ— æ­£åˆ™è§„åˆ™</div>';

                return `
                <div class="preset-card ${expandedClass}">
                    <div class="preset-header" onclick="togglePresetExpand(${preset.id})">
                        <div class="preset-title">
                            <span class="preset-arrow">â–¶</span>
                            <span onclick="event.stopPropagation(); editPresetName(${preset.id})">${preset.name}</span>
                        </div>
                        <div class="preset-actions" style="display:flex; align-items:center; gap:10px;" onclick="event.stopPropagation()">
                            <label class="switch" style="transform:scale(0.8);">
                                <input type="checkbox" ${preset.isActive ? 'checked' : ''} onchange="togglePreset(${preset.id})">
                                <span class="slider round"></span>
                            </label>
                            <button class="btn btn-sm btn-danger" style="padding:4px 8px;" onclick="deletePreset(${preset.id})">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                    <div class="preset-body">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                            <label style="font-size:12px; margin:0;">æŒ‡ä»¤æ¨¡å— (ç»“æ„åŒ–ç®¡ç†)</label>
                            <button class="btn btn-sm btn-outline" style="font-size:10px; padding:2px 8px;" onclick="addEntry(${preset.id})">+ æ·»åŠ æ¨¡å—</button>
                        </div>
                        <div class="entry-list">
                            ${entriesHtml}
                        </div>
                        
                        <div style="margin-top:20px; border-top:1px dashed rgba(0,0,0,0.1); padding-top:15px;">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                                <label style="font-size:12px; margin:0;">æ­£åˆ™è§„åˆ™é›† (åå¤„ç†)</label>
                                <div style="display:flex; gap:5px;">
                                    <button class="btn btn-sm btn-outline" style="font-size:10px; padding:2px 8px;" onclick="triggerRegexImport(${preset.id})">å¯¼å…¥JSON</button>
                                    <button class="btn btn-sm btn-outline" style="font-size:10px; padding:2px 8px;" onclick="addRegexRule(${preset.id})">+ æ·»åŠ </button>
                                </div>
                            </div>
                            <div class="regex-list">
                                ${regexHtml}
                            </div>
                        </div>
                    </div>
                </div>
                `;
            }).join('');
        }

        // --- æ¡ç›®æ“ä½œå‡½æ•° ---

        function toggleEntryExpand(presetId, entryId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.entries) {
                const entry = preset.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.isExpanded = !entry.isExpanded;
                    savePresets();
                    renderCorePresetsList();
                }
            }
        }

        function toggleEntryActive(presetId, entryId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.entries) {
                const entry = preset.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.isActive = !entry.isActive;
                    // åŒæ­¥æ›´æ–° content
                    preset.content = rebuildPresetContent(preset.entries);
                    savePresets();
                    // ä¸éœ€è¦é‡ç»˜ï¼Œå¼€å…³çŠ¶æ€æ˜¯ç»‘å®šçš„
                }
            }
        }

        function saveEntryContent(presetId, entryId, value) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.entries) {
                const entry = preset.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.content = value;
                    preset.content = rebuildPresetContent(preset.entries);
                    savePresets();
                }
            }
        }

        function editEntryTitle(presetId, entryId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.entries) {
                const entry = preset.entries.find(e => e.id === entryId);
                if (entry) {
                    const newTitle = prompt("ä¿®æ”¹æ¨¡å—æ ‡é¢˜ï¼š", entry.title);
                    if (newTitle) {
                        entry.title = newTitle;
                        preset.content = rebuildPresetContent(preset.entries);
                        savePresets();
                        renderCorePresetsList();
                    }
                }
            }
        }

        function addEntry(presetId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset) {
                if (!preset.entries) preset.entries = [];
                const name = prompt("æ–°æ¨¡å—åç§°ï¼š", "æ–°æ¨¡å—");
                if (!name) return;
                
                preset.entries.push({
                    id: Date.now(),
                    title: name,
                    content: "",
                    isActive: true,
                    isExpanded: true,
                    format: 'markdown'
                });
                preset.content = rebuildPresetContent(preset.entries);
                savePresets();
                renderCorePresetsList();
            }
        }

        function deleteEntry(presetId, entryId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.entries) {
                if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ¨¡å—å—ï¼Ÿ")) return;
                preset.entries = preset.entries.filter(e => e.id !== entryId);
                preset.content = rebuildPresetContent(preset.entries);
                savePresets();
                renderCorePresetsList();
            }
        }

        function moveEntryUp(presetId, entryId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.entries) {
                const index = preset.entries.findIndex(e => e.id === entryId);
                if (index > 0) {
                    // äº¤æ¢
                    const temp = preset.entries[index];
                    preset.entries[index] = preset.entries[index - 1];
                    preset.entries[index - 1] = temp;
                    
                    // æ›´æ–° content
                    preset.content = rebuildPresetContent(preset.entries);
                    savePresets();
                    renderCorePresetsList();
                }
            }
        }

        function moveEntryDown(presetId, entryId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.entries) {
                const index = preset.entries.findIndex(e => e.id === entryId);
                if (index !== -1 && index < preset.entries.length - 1) {
                    // äº¤æ¢
                    const temp = preset.entries[index];
                    preset.entries[index] = preset.entries[index + 1];
                    preset.entries[index + 1] = temp;
                    
                    // æ›´æ–° content
                    preset.content = rebuildPresetContent(preset.entries);
                    savePresets();
                    renderCorePresetsList();
                }
            }
        }

        // --- é¢„è®¾æ“ä½œ ---

        function addNewPreset() {
            const name = prompt("è¯·è¾“å…¥æ–°é¢„è®¾åç§°ï¼š", "æ–°é¢„è®¾ " + (state.corePresets.length + 1));
            if (!name) return;
            
            state.corePresets.push({
                id: Date.now(),
                name: name,
                content: "",
                entries: [], // åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„
                isActive: false,
                isExpanded: true,
                regexRules: []
            });
            savePresets();
            renderCorePresetsList();
        }

        function togglePreset(id) {
            const preset = state.corePresets.find(p => p.id === id);
            if (preset) {
                preset.isActive = !preset.isActive;
                savePresets();
                // ä¸éœ€è¦é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨ï¼Œå› ä¸ºå¼€å…³çŠ¶æ€æ˜¯ç›´æ¥ç»‘å®šçš„ï¼Œä½†ä¸ºäº†ä¿æŒä¸€è‡´æ€§å¯ä»¥é‡ç»˜
                // è¿™é‡Œä¸é‡ç»˜ä»¥é¿å…æŠ˜å çŠ¶æ€ä¸¢å¤±ï¼ˆè™½ç„¶æ•°æ®é‡Œå­˜äº† isExpandedï¼‰
            }
        }

        function togglePresetExpand(id) {
            const preset = state.corePresets.find(p => p.id === id);
            if (preset) {
                preset.isExpanded = !preset.isExpanded;
                savePresets();
                renderCorePresetsList();
            }
        }

        function deletePreset(id) {
            if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªé¢„è®¾å—ï¼Ÿ")) return;
            state.corePresets = state.corePresets.filter(p => p.id !== id);
            savePresets();
            renderCorePresetsList();
        }

        // savePresetContent å·²è¢« saveEntryContent æ›¿ä»£ï¼Œä½†ä¿ç•™ä»¥é˜²ä¸‡ä¸€
        function savePresetContent(id, content) {
            const preset = state.corePresets.find(p => p.id === id);
            if (preset) {
                preset.content = content;
                // å¦‚æœç›´æ¥ä¿®æ”¹äº† content (éç»“æ„åŒ–æ¨¡å¼)ï¼Œå°è¯•é‡æ–°è§£æ
                preset.entries = parseContentToEntries(content);
                savePresets();
            }
        }

        function editPresetName(id) {
            const preset = state.corePresets.find(p => p.id === id);
            if (!preset) return;
            const newName = prompt("ä¿®æ”¹é¢„è®¾åç§°ï¼š", preset.name);
            if (newName) {
                preset.name = newName;
                savePresets();
                renderCorePresetsList();
            }
        }

        function savePresets() {
            localStorage.setItem('jj_core_presets', JSON.stringify(state.corePresets));
        }

        function exportCorePreset() {
            // å¯¼å‡ºæ‰€æœ‰é¢„è®¾
            if(state.corePresets.length === 0) return alert("æ²¡æœ‰é¢„è®¾å¯å¯¼å‡º");
            const json = JSON.stringify(state.corePresets, null, 2);
            downloadFile(json, `jj_core_presets_full_${Date.now()}.json`, 'application/json');
        }

        function importCorePreset(input) {
            const file = input.files[0];
            if(!file) return;
            
            // è·å–æ–‡ä»¶åä½œä¸ºé»˜è®¤é¢„è®¾åï¼ˆå»é™¤æ‰©å±•åï¼‰
            const fileName = file.name.replace(/\.[^/.]+$/, "");

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const raw = JSON.parse(e.target.result);
                    let newPresets = [];

                    // --- æ™ºèƒ½æ ¼å¼è¯†åˆ« ---

                    // 1. SillyTavern / é«˜çº§é¢„è®¾åŒ…æ ¼å¼ (ç‰¹å¾ï¼šåŒ…å« prompts æ•°ç»„ æˆ– extensions å¯¹è±¡)
                    if (raw.prompts || (raw.extensions && raw.extensions.regex_scripts)) {
                        console.log("æ£€æµ‹åˆ°é«˜çº§é¢„è®¾åŒ…æ ¼å¼ (SillyTavern-like)");
                        
                        let entries = [];
                        let regexRules = [];

                        // A. å¤„ç† Prompts (æ„å»ºç»“æ„åŒ– entries)
                        if (Array.isArray(raw.prompts)) {
                            // æŒ‰ injection_order æ’åº
                            const sortedPrompts = raw.prompts
                                .sort((a, b) => (a.injection_order || 0) - (b.injection_order || 0));
                            
                            entries = sortedPrompts.map((p, index) => ({
                                id: Date.now() + index,
                                title: p.name || `æ¨¡å— ${index + 1}`,
                                content: p.content || "",
                                isActive: p.enabled !== false, // ä¿ç•™å¯ç”¨çŠ¶æ€
                                isExpanded: false,
                                format: 'html_comment' // é»˜è®¤ä½¿ç”¨ html æ³¨é‡Šæ ¼å¼
                            }));
                        }

                        // B. å¤„ç†æ­£åˆ™è„šæœ¬
                        if (raw.extensions && Array.isArray(raw.extensions.regex_scripts)) {
                            raw.extensions.regex_scripts.forEach((script, index) => {
                                let pattern = script.findRegex;
                                let replacement = script.replaceString || "";
                                
                                if (pattern) {
                                    regexRules.push({
                                        id: Date.now() + Math.random() + index,
                                        name: script.scriptName || "å¯¼å…¥æ­£åˆ™",
                                        pattern: pattern,
                                        replacement: replacement,
                                        isActive: !script.disabled // ä¿ç•™å¯ç”¨çŠ¶æ€
                                    });
                                }
                            });
                        }

                        // ç”Ÿæˆåˆå§‹ content (ä»…åŒ…å«å¯ç”¨çš„æ¨¡å—)
                        const initialContent = rebuildPresetContent(entries);

                        // åˆ›å»ºä¸€ä¸ªç»¼åˆé¢„è®¾
                        newPresets.push({
                            id: Date.now(),
                            name: fileName, // ä½¿ç”¨æ–‡ä»¶å
                            content: initialContent,
                            entries: entries, // ç›´æ¥ä½¿ç”¨æ„å»ºå¥½çš„ entries
                            isActive: false,
                            isExpanded: false,
                            regexRules: regexRules
                        });

                    } 
                    // 2. æ ‡å‡†æ•°ç»„æ ¼å¼ (æœ¬ç³»ç»Ÿå¯¼å‡ºæ ¼å¼)
                    else if (Array.isArray(raw)) {
                        raw.forEach(item => {
                            if (item.name) {
                                newPresets.push({
                                    id: Date.now() + Math.random(),
                                    name: item.name,
                                    content: item.content || "",
                                    entries: item.entries, // ä¿ç•™ç»“æ„åŒ–æ¡ç›®æ•°æ®
                                    isActive: false,
                                    isExpanded: false,
                                    regexRules: item.regexRules || []
                                });
                            }
                        });
                    } 
                    // 3. å•ä¸ªå¯¹è±¡æ ¼å¼ (æœ¬ç³»ç»Ÿå¯¼å‡ºæ ¼å¼)
                    else if (raw.name && (raw.content !== undefined || raw.regexRules)) {
                        newPresets.push({
                            id: Date.now(),
                            name: raw.name,
                            content: raw.content || "",
                            entries: raw.entries, // ä¿ç•™ç»“æ„åŒ–æ¡ç›®æ•°æ®
                            isActive: false,
                            isExpanded: false,
                            regexRules: raw.regexRules || []
                        });
                    }
                    else {
                        throw new Error("æ— æ³•è¯†åˆ«çš„æ–‡ä»¶æ ¼å¼ï¼Œæœªæ‰¾åˆ° prompts, extensions æˆ–æ ‡å‡†é¢„è®¾å­—æ®µ");
                    }
                    
                    // æ‰§è¡Œæ·»åŠ 
                    if (newPresets.length > 0) {
                        state.corePresets.push(...newPresets);
                        savePresets();
                        // å¼ºåˆ¶åˆ·æ–°åˆ—è¡¨ï¼Œç¡®ä¿æ–°å¯¼å…¥çš„é¢„è®¾ç«‹å³æ˜¾ç¤º
                        setTimeout(() => {
                            renderCorePresetsList();
                        }, 0);
                        alert(`æˆåŠŸå¯¼å…¥ ${newPresets.length} ä¸ªé¢„è®¾ (æ¥è‡ª: ${fileName})`);
                    } else {
                        alert("æ–‡ä»¶ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„é¢„è®¾æ•°æ®");
                    }

                } catch(err) {
                    console.error(err);
                    alert("å¯¼å…¥å¤±è´¥ï¼š" + err.message);
                }
                input.value = '';
            };
            reader.readAsText(file);
        }

        // --- æ­£åˆ™è§„åˆ™ç®¡ç† ---

        function addRegexRule(presetId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (!preset) return;
            
            const name = prompt("è§„åˆ™åç§°ï¼š", "è§„åˆ™ " + ((preset.regexRules?.length || 0) + 1));
            if (!name) return;
            
            const pattern = prompt("æ­£åˆ™è¡¨è¾¾å¼ (Pattern)ï¼š", "");
            if (!pattern) return;
            
            const replacement = prompt("æ›¿æ¢å†…å®¹ (Replacementï¼Œç•™ç©ºåˆ™åˆ é™¤)ï¼š", "");
            
            if (!preset.regexRules) preset.regexRules = [];
            preset.regexRules.push({
                id: Date.now(),
                name: name,
                pattern: pattern,
                replacement: replacement || "",
                isActive: true
            });
            
            savePresets();
            renderCorePresetsList();
        }

        function toggleRegexRule(presetId, ruleId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.regexRules) {
                const rule = preset.regexRules.find(r => r.id === ruleId);
                if (rule) {
                    rule.isActive = !rule.isActive;
                    savePresets();
                }
            }
        }

        function deleteRegexRule(presetId, ruleId) {
            const preset = state.corePresets.find(p => p.id === presetId);
            if (preset && preset.regexRules) {
                if (!confirm("ç¡®å®šåˆ é™¤æ­¤è§„åˆ™å—ï¼Ÿ")) return;
                preset.regexRules = preset.regexRules.filter(r => r.id !== ruleId);
                savePresets();
                renderCorePresetsList();
            }
        }

        // æ­£åˆ™å¯¼å…¥ç›¸å…³
        let currentImportPresetId = null;
        function triggerRegexImport(presetId) {
            currentImportPresetId = presetId;
            document.getElementById('importRegexFile').click();
        }

        function handleRegexImport(input) {
            const file = input.files[0];
            if (!file || !currentImportPresetId) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const raw = JSON.parse(e.target.result);
                    let rules = [];
                    
                    // å°è¯•è§£æè§„åˆ™æ•°ç»„
                    if (Array.isArray(raw)) {
                        rules = raw;
                    } else if (raw.rules && Array.isArray(raw.rules)) {
                        rules = raw.rules;
                    }
                    
                    const preset = state.corePresets.find(p => p.id === currentImportPresetId);
                    if (preset) {
                        if (!preset.regexRules) preset.regexRules = [];
                        let count = 0;
                        
                        rules.forEach(r => {
                            if (r.pattern) {
                                preset.regexRules.push({
                                    id: Date.now() + Math.random(),
                                    name: r.name || "å¯¼å…¥è§„åˆ™",
                                    pattern: r.pattern,
                                    replacement: r.replacement || "",
                                    isActive: true
                                });
                                count++;
                            }
                        });
                        
                        savePresets();
                        renderCorePresetsList();
                        alert(`æˆåŠŸå¯¼å…¥ ${count} æ¡æ­£åˆ™è§„åˆ™`);
                    }
                } catch(err) {
                    console.error(err);
                    alert("å¯¼å…¥å¤±è´¥ï¼š" + err.message);
                }
                input.value = '';
                currentImportPresetId = null;
            };
            reader.readAsText(file);
        }

        function renderConfigList() {
            const select = document.getElementById('savedConfigs');
            select.innerHTML = '<option value="">-- æ–°å»ºé…ç½® --</option>';
            
            const current = state.config;
            
            state.configList.forEach((cfg, index) => {
                const opt = document.createElement('option');
                opt.value = index;
                
                // åˆ¤æ–­æ˜¯å¦ä¸ºå½“å‰æ­£åœ¨ä½¿ç”¨çš„é…ç½®
                const isCurrent = current && 
                    (cfg.apiKey || '') === (current.apiKey || '') &&
                    (cfg.apiUrl || '') === (current.apiUrl || '') &&
                    (cfg.apiType || 'gemini') === (current.apiType || 'gemini') &&
                    (cfg.model || 'gemini-1.5-flash') === (current.model || 'gemini-1.5-flash');

                opt.text = cfg.name + (isCurrent ? " (å½“å‰ä½¿ç”¨ âœ”)" : "");
                if (isCurrent) {
                    opt.style.color = "var(--jj-green)";
                    opt.style.fontWeight = "bold";
                }
                select.add(opt);
            });
        }

        function fillConfigForm(config) {
            document.getElementById('apiKey').value = config.apiKey || '';
            document.getElementById('apiUrl').value = config.apiUrl || '';
            document.getElementById('apiTypeSelect').value = config.apiType || 'gemini';
            
            // ç¡®ä¿æ¨¡å‹é€‰é¡¹å­˜åœ¨
            const model = config.model || 'gemini-1.5-flash';
            const select = document.getElementById('modelSelect');
            let exists = false;
            for(let i=0; i<select.options.length; i++) {
                if(select.options[i].value === model) {
                    exists = true;
                    break;
                }
            }
            if(!exists) {
                const opt = document.createElement('option');
                opt.value = model;
                opt.text = model;
                select.add(opt);
            }
            select.value = model;
        }

        function handleApiTypeChange() {
            const type = document.getElementById('apiTypeSelect').value;
            const urlInput = document.getElementById('apiUrl');
            // ç®€å•çš„è‡ªåŠ¨å¡«å……æç¤º
            if(type === 'openai' && (!urlInput.value || urlInput.value.includes('googleapis'))) {
                urlInput.value = 'https://api.openai.com';
            } else if (type === 'gemini' && (!urlInput.value || urlInput.value.includes('openai'))) {
                urlInput.value = 'https://generativelanguage.googleapis.com';
            } else if (type === 'custom_openai' && (!urlInput.value || urlInput.value.includes('openai.com') || urlInput.value.includes('googleapis'))) {
                urlInput.value = ''; // è‡ªå®šä¹‰æ—¶æ¸…ç©ºï¼Œè®©ç”¨æˆ·å¡«
                urlInput.placeholder = "ä¾‹å¦‚: http://localhost:1234 æˆ– https://api.deepseek.com";
            }
        }

        async function loadSelectedConfig() {
            const index = document.getElementById('savedConfigs').value;
            if (index === "") {
                // æ–°å»ºæ¨¡å¼ï¼Œæ¸…ç©ºè¡¨å•
                document.getElementById('configName').value = "";
                fillConfigForm({ apiKey: '', apiUrl: '', model: 'gemini-1.5-flash', apiType: 'gemini' });
                return;
            }

            const cfg = state.configList[index];
            document.getElementById('configName').value = cfg.name;
            fillConfigForm(cfg);

            // --- ä¼˜åŒ–ï¼šä¸€é”®åº”ç”¨é€»è¾‘ ---
            // 1. åˆ‡æ¢é…ç½®
            state.config = { ...cfg };
            localStorage.setItem('jj_config', JSON.stringify(state.config));
            localStorage.setItem('jj_last_config_index', index);
            
            // æ›´æ–°åˆ—è¡¨æ˜¾ç¤ºçŠ¶æ€ï¼ˆåŠ ç²—å½“å‰é€‰ä¸­çš„ï¼‰
            renderConfigList();
            document.getElementById('savedConfigs').value = index;

            // 2. è‡ªåŠ¨æ‹‰å–å¹¶åº”ç”¨æ¨¡å‹
            const btn = document.querySelector('#modelSelect').nextElementSibling; // è·å–â€œæ‹‰å–æ¨¡å‹â€æŒ‰é’®
            if(btn) {
                const originalText = btn.innerText;
                btn.innerText = "è‡ªåŠ¨åˆ‡æ¢ä¸­...";
                btn.disabled = true;
                
                try {
                    await fetchModels(true);
                    // 3. æ™ºèƒ½åº”ç”¨æ¨¡å‹é€»è¾‘å·²é›†æˆåœ¨ fetchModels ä¸­
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            } else {
                await fetchModels(true);
            }
        }

        function saveConfig() {
            const name = document.getElementById('configName').value.trim();
            if (!name) return alert("è¯·ä¸ºé…ç½®èµ·ä¸ªåå­—");

            const newConfig = {
                name: name,
                apiKey: document.getElementById('apiKey').value.trim(),
                apiUrl: document.getElementById('apiUrl').value.trim(),
                apiType: document.getElementById('apiTypeSelect').value,
                model: document.getElementById('modelSelect').value
            };

            // è§„èŒƒåŒ– URL
            if (newConfig.apiUrl) {
                if (!newConfig.apiUrl.startsWith('http://') && !newConfig.apiUrl.startsWith('https://')) {
                    newConfig.apiUrl = 'https://' + newConfig.apiUrl;
                }
                if (newConfig.apiUrl.endsWith('/')) {
                    newConfig.apiUrl = newConfig.apiUrl.slice(0, -1);
                }
                document.getElementById('apiUrl').value = newConfig.apiUrl;
            }

            // æ£€æŸ¥æ˜¯æ›´æ–°è¿˜æ˜¯æ–°å¢
            const index = document.getElementById('savedConfigs').value;
            if (index !== "") {
                state.configList[index] = newConfig;
            } else {
                state.configList.push(newConfig);
            }

            // ä¿å­˜åˆ—è¡¨
            localStorage.setItem('jj_config_list', JSON.stringify(state.configList));
            
            // åŒæ—¶åº”ç”¨ä¸ºå½“å‰é…ç½®
            state.config = newConfig;
            localStorage.setItem('jj_config', JSON.stringify(state.config));

            alert("é…ç½®å·²ä¿å­˜å¹¶åº”ç”¨ï¼");
            loadSettingsUI(); // åˆ·æ–°åˆ—è¡¨
            
            // é€‰ä¸­åˆšæ‰ä¿å­˜çš„
            const newIndex = state.configList.findIndex(c => c.name === name);
            if(newIndex !== -1) {
                document.getElementById('savedConfigs').value = newIndex;
                localStorage.setItem('jj_last_config_index', newIndex);
            }
        }

        function deleteConfig() {
            const index = document.getElementById('savedConfigs').value;
            if (index === "") return alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é…ç½®");
            
            if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªé…ç½®å—ï¼Ÿ")) return;
            
            state.configList.splice(index, 1);
            localStorage.setItem('jj_config_list', JSON.stringify(state.configList));
            
            alert("é…ç½®å·²åˆ é™¤");
            loadSettingsUI();
        }

        function applyConfigOnly() {
            const tempConfig = {
                apiKey: document.getElementById('apiKey').value.trim(),
                apiUrl: document.getElementById('apiUrl').value.trim(),
                apiType: document.getElementById('apiTypeSelect').value,
                model: document.getElementById('modelSelect').value
            };
            
            state.config = tempConfig;
            localStorage.setItem('jj_config', JSON.stringify(state.config));
            
            // åˆ·æ–°åˆ—è¡¨ä»¥æ›´æ–°â€œå½“å‰ä½¿ç”¨â€æ ‡è®°
            const currentSelectValue = document.getElementById('savedConfigs').value;
            renderConfigList();
            document.getElementById('savedConfigs').value = currentSelectValue;

            alert("å·²ä¸´æ—¶åº”ç”¨å½“å‰è®¾ç½®ï¼ˆæœªä¿å­˜åˆ°é…ç½®åˆ—è¡¨ï¼‰");
        }

        async function fetchModels(isAuto = false) {
            let key, baseUrl, apiType;
            
            if (isAuto) {
                key = state.config.apiKey;
                baseUrl = state.config.apiUrl;
                apiType = state.config.apiType;
            } else {
                key = document.getElementById('apiKey').value.trim();
                baseUrl = document.getElementById('apiUrl').value.trim();
                apiType = document.getElementById('apiTypeSelect').value;
            }
            
            if(!key) {
                if(!isAuto) alert("è¯·å…ˆè¾“å…¥API Key");
                return;
            }
            
            if (!baseUrl) {
                if (apiType === 'gemini') baseUrl = 'https://generativelanguage.googleapis.com';
                else if (apiType === 'openai') baseUrl = 'https://api.openai.com';
                else if (!isAuto) return alert("è‡ªå®šä¹‰æ¥å£å¿…é¡»å¡«å†™ API URL");
            }
            
            if(baseUrl && baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
            
            let btn = null;
            let originalText = "";
            if (!isAuto) {
                // å°è¯•è·å–è§¦å‘äº‹ä»¶çš„æŒ‰é’®ï¼Œæˆ–è€…é€šè¿‡é€‰æ‹©å™¨æŸ¥æ‰¾
                if (event && event.target) btn = event.target;
                if (btn) {
                    originalText = btn.innerText;
                    btn.innerText = "æ‹‰å–ä¸­...";
                    btn.disabled = true;
                }
            }

            try {
                let dataModels = [];

                // --- åˆ†æ”¯ 1: Gemini ---
                if (apiType === 'gemini') {
                    let url = baseUrl;
                    if (!url.includes('/models')) {
                        if (!url.includes('/v1beta') && !url.includes('/v1')) {
                            url += '/v1beta';
                        }
                        url += '/models';
                    }
                    const separator = url.includes('?') ? '&' : '?';
                    const finalUrl = `${url}${separator}key=${key}`;

                    const response = await fetch(finalUrl);
                    if(!response.ok) throw new Error(response.statusText);
                    const data = await response.json();
                    
                    if(data.models) {
                        dataModels = data.models
                            .filter(m => m.supportedGenerationMethods && m.supportedGenerationMethods.includes("generateContent"))
                            .map(m => ({
                                id: m.name.replace('models/', ''),
                                name: `${m.name.replace('models/', '')} (${m.displayName})`
                            }));
                    }
                } 
                // --- åˆ†æ”¯ 2: OpenAI / è‡ªå®šä¹‰ ---
                else {
                    let url = baseUrl;
                    if (!url.includes('/models')) {
                        if (!url.includes('/v1')) {
                            url += '/v1';
                        }
                        url += '/models';
                    }
                    
                    const response = await fetch(url, {
                        headers: { 'Authorization': `Bearer ${key}` }
                    });
                    
                    if(!response.ok) {
                        const errText = await response.text();
                        throw new Error(`${response.status} ${errText}`);
                    }
                    
                    const data = await response.json();
                    if (data.data && Array.isArray(data.data)) {
                        dataModels = data.data.map(m => ({
                            id: m.id,
                            name: m.id
                        }));
                    }
                }

                if(dataModels.length > 0) {
                    const select = document.getElementById('modelSelect');
                    dataModels.forEach(m => {
                        let exists = false;
                        for(let i=0; i<select.options.length; i++) {
                            if(select.options[i].value === m.id) exists = true;
                        }
                        if(!exists) {
                            const opt = document.createElement('option');
                            opt.value = m.id;
                            opt.text = m.name;
                            select.add(opt);
                        }
                    });
                    
                    // è‡ªåŠ¨æ¨¡å¼ä¸‹ï¼Œå°è¯•æ¢å¤é€‰ä¸­çš„æ¨¡å‹
                    if (isAuto && state.config.model) {
                        select.value = state.config.model;
                    }
                    
                    if(!isAuto) alert(`æˆåŠŸæ‹‰å– ${dataModels.length} ä¸ªæ¨¡å‹`);
                } else {
                    if(!isAuto) alert("æœªæ‰¾åˆ°å¯ç”¨æ¨¡å‹");
                }

            } catch(e) {
                console.error(e);
                if(!isAuto) alert("æ‹‰å–æ¨¡å‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥Keyã€URLæˆ–ç½‘ç»œã€‚\n" + e.message);
            } finally {
                if(btn) {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            }
        }

        function toggleKeyVis(checkbox) {
            document.getElementById('apiKey').type = checkbox.checked ? 'text' : 'password';
        }

        // ç¼–è¾‘æ­£æ–‡
        function toggleEditBody(btn) {
            const el = document.getElementById('readerBody');
            if (el.isContentEditable) {
                // ä¿å­˜
                el.contentEditable = false;
                el.classList.remove('editable-active');
                btn.innerText = "âœï¸ ä¿®æ”¹æ­£æ–‡";
                
                // æ›´æ–°ç¼“å­˜
                if(state.currentBook && state.currentChapter) {
                    const bookId = state.currentBook.id;
                    const chapterNum = state.currentChapter;
                    state.chapterCache[bookId][chapterNum] = el.innerHTML;
                    localStorage.setItem('jj_chapter_cache', JSON.stringify(state.chapterCache));
                }
            } else {
                // ç¼–è¾‘
                el.contentEditable = true;
                el.classList.add('editable-active');
                el.focus();
                btn.innerText = "ğŸ’¾ ä¿å­˜ä¿®æ”¹";
            }
        }

        // ç¼–è¾‘ä½œè€…æœ‰è¯è¯´
        function toggleEditAuthorSay(btn) {
            const el = document.getElementById('authorSayContent');
            
            if (el.isContentEditable) {
                el.contentEditable = false;
                el.classList.remove('editable-active');
                btn.innerText = "âœï¸";
                
                // æ›´æ–°ç¼“å­˜
                if(state.currentBook && state.currentChapter) {
                    const bookId = state.currentBook.id;
                    const chapterNum = state.currentChapter;
                    state.authorSays[bookId][chapterNum] = el.innerText;
                    localStorage.setItem('jj_author_says', JSON.stringify(state.authorSays));
                }
            } else {
                el.contentEditable = true;
                el.classList.add('editable-active');
                el.focus();
                btn.innerText = "ğŸ’¾";
            }
        }

        function toggleFloatMenu() {
            const subBtns = document.getElementById('floatSubBtns');
            const mainBtn = document.querySelector('.float-btn.main-btn');
            subBtns.classList.toggle('active');
            mainBtn.classList.toggle('active');
        }

        function toggleFloatPanel(type) {
            const panels = ['author', 'plot', 'comment', 'wordcount', 'summary'];
            const targetPanelId = 'panel' + type.charAt(0).toUpperCase() + type.slice(1);
            const targetPanel = document.getElementById(targetPanelId);
            
            // å…³é—­å…¶ä»–é¢æ¿
            panels.forEach(p => {
                if (p !== type) {
                    const pid = 'panel' + p.charAt(0).toUpperCase() + p.slice(1);
                    const el = document.getElementById(pid);
                    if (el) el.classList.remove('active');
                }
            });
            
            // åˆ‡æ¢å½“å‰é¢æ¿
            if (targetPanel) {
                targetPanel.classList.toggle('active');
            }
        }

        // --- ç•Œé¢å¤–è§‚é€»è¾‘ ---

        function initAppearance() {
            const app = state.appearance;

            // é¢„ç½®å­—ä½“
            if (!app.customFonts) app.customFonts = [];
            const presetFonts = [
                { name: "éœé¹œæ–‡æ¥·", data: "https://files.catbox.moe/2ac24r.ttf", type: "font-face" },
                { name: "ZeoSevenå­—ä½“", data: '@import url("https://fontsapi.zeoseven.com/165/main/result.css");', type: "css" }
            ];
            let hasNew = false;
            presetFonts.forEach(pf => {
                if (!app.customFonts.some(f => f.name === pf.name)) {
                    app.customFonts.push(pf);
                    hasNew = true;
                }
            });
            if (hasNew) saveAppearance();
            
            // åˆå§‹åŒ–é»˜è®¤ä¸»é¢˜
            if (!state.appearance.themes || state.appearance.themes.length === 0) {
                state.appearance.themes = [
                    {
                        name: "é¢„è®¾1: é»˜è®¤è–„é›¾",
                        config: {
                            bgImage: null, bgBlur: 0, bgMask: 0, isDark: false, font: 'default',
                            customCSS: "" // é»˜è®¤æ ·å¼å·²åœ¨ CSS ä¸­å®šä¹‰ï¼Œæ— éœ€è¦†ç›–
                        }
                    },
                    {
                        name: "é¢„è®¾2: è“ç™½å¹»æƒ³",
                        config: {
                            bgImage: null, bgBlur: 0, bgMask: 0, isDark: false, font: 'default',
                            customCSS: `:root {
    --bg-color: #f0f8ff;
    --text-main: #1a3c5e;
    --text-sub: #5d8aa8;
    --glass-bg: rgba(240, 248, 255, 0.85);
    --glass-border: rgba(176, 224, 230, 0.6);
    --jj-green: #4682b4;
    --jj-light-green: rgba(70, 130, 180, 0.15);
    --jj-pink: #ffb7b2;
    --reader-bg: rgba(245, 250, 255, 0.95);
}`
                        }
                    }
                ];
                saveAppearance();
            }
            
            // 1. åº”ç”¨èƒŒæ™¯
            applyBackground(app.bgImage, app.bgBlur, app.bgMask);
            
            // 2. åº”ç”¨æ·±è‰²æ¨¡å¼
            if (app.isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
            
            // 3. åŠ è½½è‡ªå®šä¹‰å­—ä½“
            if (app.customFonts && app.customFonts.length > 0) {
                app.customFonts.forEach(font => loadCustomFont(font.name, font.data, font.type));
            }
            
            // 4. åº”ç”¨å­—ä½“
            if (app.font && app.font !== 'default') {
                document.documentElement.style.setProperty('--font-sans', `"${app.font}", system-ui, sans-serif`);
            }

            // 5. æ¸²æŸ“ä¸»é¢˜åˆ—è¡¨
            renderThemeList();

            // 6. åº”ç”¨è‡ªå®šä¹‰ CSS
            applyCustomCSS(app.customCSS);
        }

        function applyBackground(imgData, blur, mask) {
            const bgEl = document.getElementById('app-background');
            const maskEl = document.getElementById('app-mask');
            
            if (imgData) {
                bgEl.style.backgroundImage = `url(${imgData})`;
            } else {
                // é»˜è®¤èƒŒæ™¯
                bgEl.style.backgroundImage = `
                    radial-gradient(at 10% 10%, rgba(96, 125, 139, 0.05) 0px, transparent 50%),
                    radial-gradient(at 90% 90%, rgba(200, 200, 200, 0.1) 0px, transparent 50%)
                `;
            }
            
            bgEl.style.filter = `blur(${blur}px)`;
            maskEl.style.opacity = mask / 100;
        }

        function handleBgUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result;
                state.appearance.bgImage = base64;
                saveAppearance();
                applyBackground(base64, state.appearance.bgBlur, state.appearance.bgMask);
                input.value = '';
            };
            reader.readAsDataURL(file);
        }

        function resetBg() {
            state.appearance.bgImage = null;
            state.appearance.bgBlur = 0;
            state.appearance.bgMask = 0;
            saveAppearance();
            applyBackground(null, 0, 0);
            
            // æ›´æ–°UIæ§ä»¶
            document.getElementById('bgBlur').value = 0;
            document.getElementById('bgMask').value = 0;
            document.getElementById('blurVal').innerText = "0px";
            document.getElementById('maskVal').innerText = "0%";
        }

        function updateAppearancePreview() {
            const blur = document.getElementById('bgBlur').value;
            const mask = document.getElementById('bgMask').value;
            
            document.getElementById('blurVal').innerText = blur + "px";
            document.getElementById('maskVal').innerText = mask + "%";
            
            state.appearance.bgBlur = blur;
            state.appearance.bgMask = mask;
            saveAppearance();
            
            applyBackground(state.appearance.bgImage, blur, mask);
        }

        function toggleDarkMode() {
            const isDark = document.getElementById('darkModeSwitch').checked;
            state.appearance.isDark = isDark;
            saveAppearance();
            
            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
        }

        function handleFontUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            // ç®€å•çš„é™åˆ¶æç¤º
            if (file.size > 3 * 1024 * 1024) {
                if(!confirm("å­—ä½“æ–‡ä»¶è¾ƒå¤§ (>3MB)ï¼Œå¯èƒ½ä¼šå¯¼è‡´æµè§ˆå™¨å­˜å‚¨ç©ºé—´ä¸è¶³è€Œä¿å­˜å¤±è´¥ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ")) {
                    input.value = '';
                    return;
                }
            }

            const fontName = file.name.split('.')[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result;
                
                try {
                    // ä¿å­˜å­—ä½“æ•°æ®
                    if (!state.appearance.customFonts) state.appearance.customFonts = [];
                    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                    const idx = state.appearance.customFonts.findIndex(f => f.name === fontName);
                    if (idx !== -1) {
                        state.appearance.customFonts[idx] = { name: fontName, data: base64 };
                    } else {
                        state.appearance.customFonts.push({ name: fontName, data: base64 });
                    }
                    
                    saveAppearance();
                    loadCustomFont(fontName, base64);
                    
                    // åˆ·æ–°ä¸‹æ‹‰æ¡†å¹¶é€‰ä¸­
                    renderFontSelect();
                    document.getElementById('fontSelect').value = fontName;
                    changeFont();
                    
                    alert(`å­—ä½“ "${fontName}" ä¸Šä¼ å¹¶ä¿å­˜æˆåŠŸï¼`);
                } catch (err) {
                    console.error(err);
                    alert("ä¿å­˜å¤±è´¥ï¼šå¯èƒ½æ˜¯æœ¬åœ°å­˜å‚¨ç©ºé—´ä¸è¶³ (LocalStorageé€šå¸¸é™åˆ¶5MB)ã€‚\nå»ºè®®åˆ é™¤ä¸€äº›æ—§ä¸»é¢˜æˆ–å­—ä½“åå†è¯•ã€‚");
                    // å›æ»šå†…å­˜çŠ¶æ€
                    if(state.appearance.customFonts.length > 0 && state.appearance.customFonts[state.appearance.customFonts.length-1].name === fontName) {
                         state.appearance.customFonts.pop();
                    }
                }
                input.value = '';
            };
            reader.readAsDataURL(file);
        }

        function addExternalFont() {
            const urlInput = document.getElementById('externalFontUrl');
            const nameInput = document.getElementById('externalFontName');
            const url = urlInput.value.trim();
            const name = nameInput.value.trim();

            if (!url || !name) return alert("è¯·è¾“å…¥å­—ä½“URL/ä»£ç å’Œå­—ä½“åç§°");

            // ç®€å•çš„ç±»å‹åˆ¤æ–­
            let type = 'font-face';
            if (url.includes('@import') || url.toLowerCase().endsWith('.css') || url.includes('<link')) {
                type = 'css';
            }

            if (!state.appearance.customFonts) state.appearance.customFonts = [];
            
            // æŸ¥é‡
            const idx = state.appearance.customFonts.findIndex(f => f.name === name);
            if (idx !== -1) {
                if(!confirm(`å­—ä½“ "${name}" å·²å­˜åœ¨ï¼Œè¦è¦†ç›–å—ï¼Ÿ`)) return;
                state.appearance.customFonts[idx] = { name, data: url, type };
            } else {
                state.appearance.customFonts.push({ name, data: url, type });
            }

            saveAppearance();
            loadCustomFont(name, url, type);
            
            renderFontSelect();
            document.getElementById('fontSelect').value = name;
            changeFont();
            
            alert("ç½‘ç»œå­—ä½“å·²æ·»åŠ ï¼");
            urlInput.value = '';
            nameInput.value = '';
        }

        function deleteCustomFont() {
            const fontName = document.getElementById('fontSelect').value;
            if (fontName === 'default') return alert("é»˜è®¤å­—ä½“ä¸å¯åˆ é™¤");
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤å­—ä½“ "${fontName}" å—ï¼Ÿ`)) return;
            
            state.appearance.customFonts = state.appearance.customFonts.filter(f => f.name !== fontName);
            
            // å¦‚æœå½“å‰æ­£åœ¨ä½¿ç”¨è¯¥å­—ä½“ï¼Œé‡ç½®ä¸ºé»˜è®¤
            if (state.appearance.font === fontName) {
                state.appearance.font = 'default';
                changeFont();
            }
            
            saveAppearance();
            renderFontSelect();
            document.getElementById('fontSelect').value = state.appearance.font;
            
            // ç§»é™¤æ ·å¼æ ‡ç­¾
            const styleId = `font-style-${fontName}`;
            const styleEl = document.getElementById(styleId);
            if (styleEl) styleEl.remove();
            
            alert("å­—ä½“å·²åˆ é™¤");
        }

        function loadCustomFont(name, data, type) {
            const styleId = `font-style-${name}`;
            // å¦‚æœå·²å­˜åœ¨ï¼Œå…ˆç§»é™¤ï¼ˆä¸ºäº†æ”¯æŒè¦†ç›–æ›´æ–°ï¼‰
            const exist = document.getElementById(styleId);
            if (exist) exist.remove();
            
            // å…¼å®¹æ—§æ•°æ®ï¼ˆæ²¡æœ‰ type å±æ€§ï¼Œdata æ˜¯ base64ï¼‰
            if (!type) {
                if (data.includes('@import') || data.trim().startsWith('<link')) {
                    type = 'css';
                } else {
                    type = 'font-face';
                }
            }

            if (type === 'css') {
                // å¤„ç† CSS å¼•å…¥
                if (data.trim().startsWith('<link')) {
                    const hrefMatch = data.match(/href=["'](.*?)["']/);
                    if (hrefMatch) {
                        const link = document.createElement('link');
                        link.id = styleId;
                        link.rel = 'stylesheet';
                        link.href = hrefMatch[1];
                        document.head.appendChild(link);
                    }
                } else if (data.includes('@import')) {
                    const style = document.createElement('style');
                    style.id = styleId;
                    style.textContent = data;
                    document.head.appendChild(style);
                } else {
                    // å‡è®¾æ˜¯çº¯ URL (.css)
                    const link = document.createElement('link');
                    link.id = styleId;
                    link.rel = 'stylesheet';
                    link.href = data;
                    document.head.appendChild(link);
                }
            } else {
                // font-face (Base64 æˆ– URL)
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
                    @font-face {
                        font-family: "${name}";
                        src: url("${data}");
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function renderFontSelect() {
            const select = document.getElementById('fontSelect');
            // ä¿ç•™ç¬¬ä¸€ä¸ªé»˜è®¤é€‰é¡¹
            select.innerHTML = '<option value="default">é»˜è®¤å­—ä½“</option>';
            
            if (state.appearance.customFonts) {
                state.appearance.customFonts.forEach(f => {
                    const opt = document.createElement('option');
                    opt.value = f.name;
                    opt.text = f.name;
                    select.add(opt);
                });
            }
            
            // é€‰ä¸­å½“å‰å­—ä½“
            select.value = state.appearance.font || 'default';
            
            // å¦‚æœé€‰ä¸­çš„æ˜¯è‡ªå®šä¹‰å­—ä½“ï¼Œå›æ˜¾URLåˆ°è¾“å…¥æ¡†
            const currentFont = state.appearance.customFonts?.find(f => f.name === select.value);
            if (currentFont && (currentFont.type === 'css' || currentFont.data.startsWith('http'))) {
                document.getElementById('externalFontUrl').value = currentFont.data;
                document.getElementById('externalFontName').value = currentFont.name;
            } else {
                document.getElementById('externalFontUrl').value = '';
                document.getElementById('externalFontName').value = '';
            }
        }

        function changeFont() {
            const fontName = document.getElementById('fontSelect').value;
            state.appearance.font = fontName;
            saveAppearance();
            
            if (fontName === 'default') {
                document.documentElement.style.removeProperty('--font-sans');
                document.documentElement.style.removeProperty('--font-serif');
            } else {
                const fontVal = `"${fontName}", system-ui, sans-serif`;
                document.documentElement.style.setProperty('--font-sans', fontVal);
                document.documentElement.style.setProperty('--font-serif', `"${fontName}", serif`);
            }
            
            // æ›´æ–°è¾“å…¥æ¡†å›æ˜¾
            renderFontSelect();
        }

        function saveCurrentTheme() {
            const name = prompt("è¯·è¾“å…¥ä¸»é¢˜åç§°ï¼š");
            if (!name) return;
            
            // è§„åˆ™2ï¼šåŠ å›ºä¸»é¢˜é¢„è®¾çš„æ•°æ®ç»‘å®šä¸å­˜å‚¨
            // ç»‘å®šä¿å­˜ï¼šå½“ç”¨æˆ·ä¿å­˜ä¸»é¢˜æ—¶ï¼Œé¢„è®¾åç§°å¿…é¡»ä¸å…¶å¯¹åº”çš„å®Œæ•´ã€ç‹¬ç«‹çš„CSSç¾åŒ–ä»£ç å—ä½œä¸ºä¸€æ¡ä¸å¯åˆ†å‰²çš„è®°å½•è¿›è¡Œç»‘å®šä¸å­˜å‚¨ã€‚
            const currentInputCSS = document.getElementById('customCSSInput').value;
            state.appearance.customCSS = currentInputCSS; // åŒæ­¥åˆ°çŠ¶æ€

            const themeConfig = {
                bgImage: state.appearance.bgImage,
                bgBlur: state.appearance.bgBlur,
                bgMask: state.appearance.bgMask,
                isDark: state.appearance.isDark,
                font: state.appearance.font,
                customCSS: currentInputCSS // æ ¸å¿ƒï¼šç»‘å®šå®Œæ•´çš„CSSä»£ç ï¼Œç¡®ä¿è®°å½•ä¸å¯åˆ†å‰²
            };
            
            if (!state.appearance.themes) state.appearance.themes = [];
            state.appearance.themes.push({ name, config: themeConfig });
            state.appearance.activeThemeIndex = state.appearance.themes.length - 1;
            saveAppearance();
            renderThemeList();
            alert("ä¸»é¢˜ä¿å­˜æˆåŠŸï¼");
        }

        function renderThemeList() {
            const select = document.getElementById('themeSelect');
            select.innerHTML = '<option value="">-- é€‰æ‹©ä¸»é¢˜ --</option>';
            
            if (state.appearance.themes) {
                state.appearance.themes.forEach((t, idx) => {
                    const opt = document.createElement('option');
                    opt.value = idx;
                    opt.text = t.name;
                    if (state.appearance.activeThemeIndex !== undefined && String(state.appearance.activeThemeIndex) === String(idx)) {
                        opt.selected = true;
                    }
                    select.add(opt);
                });
            }
        }

        function loadTheme() {
            const idx = document.getElementById('themeSelect').value;
            if (idx === "") return;
            
            state.appearance.activeThemeIndex = idx;

            const theme = state.appearance.themes[idx];
            if (!theme) return;
            
            const cfg = theme.config;
            
            // æ›´æ–°çŠ¶æ€
            state.appearance.bgImage = cfg.bgImage;
            state.appearance.bgBlur = cfg.bgBlur;
            state.appearance.bgMask = cfg.bgMask;
            state.appearance.isDark = cfg.isDark;
            state.appearance.font = cfg.font;
            // è§„åˆ™2ï¼šç¨³å®šåŠ è½½
            // ç³»ç»Ÿå¿…é¡»å‡†ç¡®è°ƒç”¨å…¶ç»‘å®šçš„å®Œæ•´CSSä»£ç 
            state.appearance.customCSS = cfg.customCSS || ""; 
            
            saveAppearance();
            
            // åº”ç”¨æ•ˆæœ
            applyBackground(cfg.bgImage, cfg.bgBlur, cfg.bgMask);
            
            if (cfg.isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
            
            if (cfg.font && cfg.font !== 'default') {
                document.documentElement.style.setProperty('--font-sans', `"${cfg.font}", system-ui, sans-serif`);
            } else {
                document.documentElement.style.removeProperty('--font-sans');
            }

            // è§„åˆ™2ï¼šç¡®ä¿è¯¥ä»£ç å®Œæ•´ç”Ÿæ•ˆï¼Œä¸å‘ç”Ÿç‰‡æ®µé”™ä½ã€ä¸¢å¤±æˆ–æ„å¤–è¢«é»˜è®¤ç¾åŒ–æ–¹æ¡ˆé‡ç½®
            applyCustomCSS(state.appearance.customCSS);
            
            // åˆ·æ–°UI (è¿™ä¼šæ›´æ–° customCSSInput çš„å€¼ï¼Œç¡®ä¿ç”¨æˆ·çœ‹åˆ°çš„æ˜¯å½“å‰ç”Ÿæ•ˆçš„ä»£ç )
            loadSettingsUI(); 
        }

        function deleteTheme() {
            const select = document.getElementById('themeSelect');
            const idx = select.value;
            if (idx === "") return alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„ä¸»é¢˜");
            
            const theme = state.appearance.themes[idx];
            // ä¿æŠ¤é»˜è®¤ä¸»é¢˜ï¼šåç§°åŒ…å«"é¢„è®¾"æˆ–"é»˜è®¤"çš„ä¸å¯åˆ é™¤
            if (theme.name.includes("é¢„è®¾") || theme.name.includes("é»˜è®¤")) {
                return alert("ç³»ç»Ÿé»˜è®¤ä¸»é¢˜é¢„è®¾ä¸å¯åˆ é™¤ï¼Œä»¥ç¡®ä¿åŸºç¡€æ ·å¼å¯ç”¨ã€‚");
            }

            // ç¡®è®¤åˆ é™¤ï¼šå¼ºè°ƒåç§°ä¸CSSçš„ç»‘å®šå…³ç³»
            if (!confirm(`ç¡®å®šè¦åˆ é™¤ä¸»é¢˜â€œ${theme.name}â€å—ï¼Ÿ\næ­¤æ“ä½œå°†åŒæ­¥åˆ é™¤å…¶ç»‘å®šçš„é¢„è®¾åç§°å’Œå…¨éƒ¨CSSä»£ç ï¼Œä¸”ä¸å¯æ¢å¤ã€‚`)) return;
            
            // æ‰§è¡Œåˆ é™¤ï¼šä»æ•°ç»„ä¸­ç§»é™¤ï¼Œå³åŒæ—¶ç§»é™¤äº†åç§°å’ŒCSSé…ç½®
            state.appearance.themes.splice(idx, 1);
            
            // æ›´æ–°å½“å‰æ¿€æ´»ç´¢å¼•
            if (state.appearance.activeThemeIndex !== undefined) {
                if (String(state.appearance.activeThemeIndex) === String(idx)) {
                    delete state.appearance.activeThemeIndex;
                } else if (state.appearance.activeThemeIndex > idx) {
                    state.appearance.activeThemeIndex--;
                }
            }

            saveAppearance();
            renderThemeList();
            select.value = ""; // é‡ç½®é€‰æ‹©
        }

        function saveAppearance() {
            localStorage.setItem('jj_appearance', JSON.stringify(state.appearance));
        }

        function saveAndApplyCSS() {
            const css = document.getElementById('customCSSInput').value;
            state.appearance.customCSS = css;
            saveAppearance();
            applyCustomCSS(css);
            alert("å…¨å±€ç¾åŒ–å·²åº”ç”¨ï¼");
        }

        function handleCSSUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const css = e.target.result;
                document.getElementById('customCSSInput').value = css;
                saveAndApplyCSS();
                input.value = '';
            };
            reader.readAsText(file);
        }

        function applyCustomCSS(css) {
            const styleId = 'custom-css-style';
            let style = document.getElementById(styleId);
            if (!style) {
                style = document.createElement('style');
                style.id = styleId;
                document.head.appendChild(style);
            }
            style.textContent = css || "";
        }

        // ä¿®æ”¹ loadSettingsUI ä»¥åŒ…å«å¤–è§‚è®¾ç½®çš„å›æ˜¾
        const originalLoadSettingsUI = loadSettingsUI;
        loadSettingsUI = function() {
            if (typeof originalLoadSettingsUI === 'function') originalLoadSettingsUI();
            
            // ç¡®ä¿æ ¸å¿ƒé¢„è®¾åˆ—è¡¨è¢«æ¸²æŸ“
            loadCoreSettingsUI();
            
            // å›æ˜¾å¤–è§‚è®¾ç½®
            const app = state.appearance;
            document.getElementById('bgBlur').value = app.bgBlur || 0;
            document.getElementById('bgMask').value = app.bgMask || 0;
            document.getElementById('blurVal').innerText = (app.bgBlur || 0) + "px";
            document.getElementById('maskVal').innerText = (app.bgMask || 0) + "%";
            document.getElementById('darkModeSwitch').checked = app.isDark || false;
            document.getElementById('customCSSInput').value = app.customCSS || "";
            
            // å›æ˜¾å­—ä½“å¤§å°
            const fontSize = app.fontSize || 16;
            document.getElementById('fontSizeSlider').value = fontSize;
            document.getElementById('fontSizeVal').innerText = fontSize + "px";

            renderFontSelect();
            renderThemeList();

            // æ–°å¢ï¼šå›æ˜¾ä¸Šæ¬¡é€‰ä¸­çš„é…ç½®
            const lastIndex = localStorage.getItem('jj_last_config_index');
            if (lastIndex !== null && state.configList[lastIndex]) {
                const select = document.getElementById('savedConfigs');
                if(select) select.value = lastIndex;
            }
        };

        // --- å­—ä½“å¤§å°ç®¡ç†é€»è¾‘ ---

        function changeFontSize() {
            const size = document.getElementById('fontSizeSlider').value;
            document.getElementById('fontSizeVal').innerText = size + "px";
            state.appearance.fontSize = parseInt(size);
            saveAppearance();
            applyFontSize(size);
        }

        function applyFontSize(size) {
            if(!size) size = 16;
            const styleId = 'global-font-size-style';
            let style = document.getElementById(styleId);
            if (!style) {
                style = document.createElement('style');
                style.id = styleId;
                document.head.appendChild(style);
            }
            // è¦†ç›–ä¸»è¦å…ƒç´ çš„å­—å·
            const s = parseInt(size);
            style.textContent = `
                html { font-size: ${s}px; }
                body { font-size: ${s}px; }
                .reader-content { font-size: ${s + 2}px; }
                h1 { font-size: ${s * 2}px; }
                h2 { font-size: ${s * 1.5}px; }
                h3 { font-size: ${s * 1.17}px; }
                .header-logo { font-size: ${s * 2.2}px; }
                .nav-item { font-size: ${Math.max(12, s - 4)}px; }
            `;
        }

        // åˆå§‹åŒ–å¤–è§‚
        initAppearance();
        applyFontSize(state.appearance.fontSize);
        
        // åˆå§‹åŒ–æ—¶åº”ç”¨ä¿å­˜çš„å­—ä½“æ ·å¼
        if (state.appearance.activeFontStyle && state.appearance.fontStyles) {
            const style = state.appearance.fontStyles.find(s => s.name === state.appearance.activeFontStyle);
            if (style) {
                applyFontStyle(style.css);
            }
        }

        // è‡ªåŠ¨æ‹‰å–æ¨¡å‹ (å¦‚æœå·²é…ç½®)
        if (state.config.apiKey) {
            fetchModels(true);
        }

        navTo('home');
    </script>
</body>
</html>
